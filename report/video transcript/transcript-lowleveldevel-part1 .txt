Raspberry Pi Bare Metal Tutorial - Part 1 - YouTube
https://www.youtube.com/watch?v=pd9AVmcRc6U


this first set of videos is going to be based on a set of tutorials by sergey matukovic on github i'll paste the link in the description it's a very interesting set of tutorials which goes in depth on how things are implemented in linux as well in these videos i will focus only on the raspberry pi side of things but will also show you 

where to find the information in the data sheets and device tree files that you need to do this sort of bare metal development 

i'm going to try to keep these videos fairly short maybe 20 to 30 minutes so i'll set their separate them into multiple sections in this first section we're going to go over the setup of the main project mainly i'm going to assume that you have at least some experience with c in assembly programming so i'm not going to spend time explaining what all the code does unless it's directly related to the hardware i'm going to be 

using visual studio code for the development and linux for the operating system if you're running windows i would suggest you create a linux virtual machine if you don't want to create a linux virtual machine and are running windows then there are other ways to run the cross compiler for instance following sergey's method of using docker i'll leave that process up to you as the first step we're going to need to install the cross compiler to compile arm code on a intel machine if you're running a debian based os you can run the following command sudo apt install gcc dash arch 64-linux dash canoe any other non-debian os i assume you know how to find a cross compiler for your system and we'll see here if we run dash v we show the version of the compiler for that specific architecture now let's create the basic structure for the project i'll create a new directory for the project and change into it and create a couple of subdirectories src and include then i'm going to open visual studio code in this directory all right so we'll create a make file here first and along with some initial header files just to get things kind of started here s kernel dot c okay to linker script mm-dos that's for our memory management utils.s for any utility classes in the mini uart.c file i like to include a common header here for some common types that i'll use in the project and we had a peripheral section with the
(03:23) base.h the code developed in here will be very similar to sergey's lessons but i'll diverge from him on a little bit on the design now let's go ahead and start with the make file i'm gonna start by adding a variable for the raspberry pi version because we want to be able to build for both pi 3 and 4 and then i'm going to add a variable for the boot mount which is where i'm going to copy the files after compiling and now after that we'll set up a base name for the cross compiler which we
(04:03) installed yours might be slightly different if you're using a different cross piler than i am next we'll create some c options to send to the c compiler since this is bare metal we will not have standard libraries and it'll be freestanding we want to pass our include directory as well and specify to use general registers only now for the assembly options you're gonna pass the include path again and we'll set up a build in a source directory now we start with the all build section
(05:08) for all we build the kernel image for clean we want to clean out the build directory remove it and clear up any image files now for all compiled c objects we'll reference their c files here be sure to create their build directory if it doesn't exist then we'll call the arm cross compiler gcc with the c options specified compile only and the output file and we're going to do the same for the assembly files here
(06:12) just copy and paste and change a couple things should be it and we're going to create some variables for the files we're going to be compiling and building using the wild card for all c files and we'll do the same for assembly files and we're going to load all of the object files here these would be the object files related to the c files and we also want to add to that the object files related to the assembly files
(07:24) and change this to and let's add a section for our dependency files all right and include and now for the section on our kernel image it's going to depend on the linker script and object files we'll add some echo output here to display the variables we know if we pass them in we have the right values we'll do for the rpi version and let's do for the mount too and an extra line
(08:40) we're going to run the cross compilers ld command to link the object files into one executable elf file and we want to convert that l file into a raw binary executable image we'll use object copy for that and now if we're going to be building with the pi 4 image we want to rename the kernel file so we can have both on the disk at the same time makes for testing on multiple devices easier so we'll use this if eq rpi version 4.
(09:44) we're going to copy the kernel 8. image to our boot mount as rpi4.image otherwise we'll just keep the default name kernel 8.image so these get copied onto the sd card we'll cover the sd card more in detail later and finally we're going to copy the config config.txt file there as well okay so let's test out our make file first we open a medu terminal window and like to run make clean first just in case there any previous files were there then we just run make now we can see from the output that the files we created were compiled
(10:35) and even though they are empty it runs through the build steps and it looks like there was one error here due to a missing config text file so let's just go ahead and create that file first we need to specify that we're using arms 64-bit so it picks up the correct kernel file name when booting next i like to add in some uart second stage debug info and supplied by the firmware that helps debug if there's any uart issues or if the code's just not working and then we add this bt overlay because without it
(11:23) sometimes bluetooth devices conflict and then we have our raspberry pi 4 section to rename the kernel for pi 4. now if we just rerun the make command here we'll see that it succeeds now let's start writing some of the code we'll start with the base dot h under peripherals add a pragma once at the top which is a way to tell the compiler only include the file once much shorter than the using the if defs and it's very widely supported so then we're gonna add some an if here if pi version is three we're going to
(12:06) use the p base starting with three f else if it's version 4 then we're going to use the pi 4's p base which starts at f e and then finally an l section here so it'll break the build if if the version is not supported or if you just forget to provide one and and now i'll show you where these values come from first we can go to the raspberry pi documentation site i'll put the url in the description under documentation hardware raspberry pi and the pi 3 is a bcm2837 which is a modified 2835 the 2835 has a full data sheet here
(13:06) let's go to that you should definitely down this download this pdf file for reference and the pi4 is a bcm2711 so let's download that one's full datasheet now opening the datasheet for the 2835 we can go down to section 1.2.3 that has the physical addresses there we go this section says that the address range starts at the beginning of the address 0x20 which you'll see right here and this address section is for
(14:10) peripherals and ze00 to start with is the bus address so when the peripheral showing the bus address starting at ze it'll translate to 2 0. now let's look at the pi 4 so the pi 4 also defines this data you'll find all kind of information about the peripheral address in here as well but you know what instead of looking at this we can actually use the device tree information from the last raspberry pi linux source tree and i'll paste that address in the comment section as well so let's go ahead and open that up
(15:01) so you'll see raspberry pi linux and if we go under arch and arm boot the dts section here we'll find all the dts files for the raspberry pi and remember the bcm2835 is what is used as a base so we can open this dtsi file in here and let's see we see this soc section which has a section for ranges and then in the ranges we can see the bus address and peripheral address which were mentioned see but wait we put 3f as the start address but remember the pi 3 is a 2837 so let's open that 2837 is a modified 2835
(16:05) so you can see in this one's ranges we have the right same bus address but here we have the the address starting at 3f so now let's go into the 2711 file and this one we also see the soc ranges with the bus address same place and here's where you see the fe as the start of the peripheral address so that's where these two important addresses come from it shows you where to find this information when you're developing and i think that's a good stopping point for this first video so in the next video we'll
(16:50) continue on with some of the other header files and get on to the boot code eventually and again welcome to the low level devil channel if you like this video please subscribe comment and thanks for watching


