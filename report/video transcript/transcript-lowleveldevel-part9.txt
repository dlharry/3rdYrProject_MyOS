Raspberry Pi Bare Metal Tutorial - Part 9 (Timers) - YouTube
https://www.youtube.com/watch?v=2dlBZoLCMSc

Transcript:
(00:01) hi and welcome back to the low level devil channel's raspberry pi bare metal series if you haven't seen the previous videos in this series take a look at the comments section i'll post a link to the playlist in the previous video we learned how to set up the interrupt vectors and handle interrupts in our kernel now in the next video i want to show you how to use more of the interrupts specifically the system timer interrupts now before moving on first i want to cover one issue with the previous video
(00:30) while putting together this video i noticed some strange behavior in the mini uart interrupts they were affecting the system timer on further research i learned there were some actually some errors in the data sheet so let's get started by taking a look at the errata page of the data sheet so if we open up this url here we can see the bcm2835 datasheet errata and under p12 we have the aux mui error register now two things important to note here is bits two and three are marked as don't care but they're actually required in
(01:12) order to receive interrupts correctly and bit ones and zero are swapped so bit zero is the receive interrupt whereas bit one is the transmit so and we were setting yeah bit one so now what we want to change this to is d so that'll set that bits three and two and bit zero so now it should be working correctly so let's go along create a timer dot h in our peripherals and we're going to start with a pragma once right and actually first let's go over the irqs so we want to change these video core irqs to add a couple of
(01:54) other irq's that we can handle and these are going to be in section 6.2.4 of the datasheet so if we open that datasheet here you can see the video core interrupts are listed here so we have zero one two and three are for system timer zero one two and three so these are the bits we're gonna care about in addition to of course our aux the 29th bit that we're using already so let's go ahead and come back to this enum here i'm gonna add one first for cis timer higher q zero where one and uh set that value to one
(02:45) we have two three and four these are going to go in powers of two so we got one two four and eight all right so now that we have those set up let's go back over here into the timer timer.h file and we'll start by doing the uh structure for the timers include our headers and we're gonna actually make it define for the clock hertz this is how fast the system timer clock runs and that number is one million because it's one megahertz timer so this is going to be in section 10.
(03:32) 2 the timer registers so let's go back to the data sheet and open that up and take a look i already have it open here so we have the system timer registers you'll notice that this is at address [Music] let's see 3 000 so we'll have to append that to our base so now at offset 0 we have the cs register aka control status register then we have a c low and c high followed by c 0 through c 3 for the system timer compare for 0 1 2 and 3.
(04:13) these map to the that same uh list that we have here so let's go to our timer so we just need to add some values for this start out with control status that was the first register see then we had our counter low and our counter high and compare radications we have four of them so you can see that maps directly to the csc low c high c04 c03 and let's add a defined so that we can access this structure call it regs timer and we're going to go from p base plus 0x zero zero zero zero and three thousand so now we'll be able to make use of that
(05:18) in our code now let's see you go over here to our not mini uart our irq dot c let's actually create a new file here timer dot c and we're going to start by adding including some headers so now let's start with our timer init function so this is going to initialize our timer and actually let's add a const value here for our interval that we're going to uh initialize it to we're going to initialize it to clock hertz so it should essentially mean every one second it's going already else and we'll create
(06:24) a value to hold the the current value of our clock as well so now when we initialize it the first thing we're going to want to do is set this current value to our regs timer and we're going to get the control low so that's going to give us the low 32 bits of our 64-bit counter so now our current value we want to add add the interval to it so basically we're getting the current value we're setting the new value to be that plus the clock hertz and we're going to set that on compare 1 we'll set that value so that's going to
(07:12) trigger an interrupt whenever this goes to here and compare one maps over here to irq one let's see actually i think we need to rename those irqs because they s they're zero based let me check here yeah so uh this should be hierarchy 0 our q1 our q2 and rq3 so now irq1 is the one that we're going to map that to and that one we know is usable because they're all not all usable some are used by the video core internally so now we've set our compare register for the next value that it's going to
(07:58) pick up so let's go over to our irq dot c file we're going to actually add that when we enable the interrupt controller right now we're just doing a ux irq so now i want to say yeah also we're gonna add cis timer irq1 we'll do that for both three and four and let's see we need to add it in the handler as well here so in our little loop here we're also going to check if it's the system timer one if so first we're going to unset that bit from our irq that we read and handle it let's just call it handle timer1
(08:44) so we need to create a function for that first we'll add that over to the header include this header to timer.h we're going to create another timer this this uh timer.h is just going to be for the kernel and others to use for the shared functions so we have the timer in it and that handle timer one so going back to here we'll create a function called handle timer one and this is going to be a pretty simple function all we're going to do okay the first thing we want to do is get our current value 1
(09:44) and we're going to add again add this interval 1 to it and the same thing we did here before we're going to set our compare register to that current value and next we're going to want to use another register here the control status register we want to or equal on to it the cis timer irq1 so that'll tell it to go start again with the comparisons and we'll just print a little message timer one received so we should see that every clock hurts so every one second so let's go ahead and let me see
(10:39) we'll start build actually first yeah we want to initialize the timer so inside of our kernel we're going to call timer in it and uh so now the kernel will initialize it right after it enables the irqs so we should be ready to do a build here make clean let's uh make for version raspberry pi 3 build successful so i'm going to go ahead and set up the pi put my sd card in it and let's boot it up all right so here we have a section level one timer one received and you can see about every one second we're getting
(11:26) that looks like we forgot to put a return there so let's go ahead and add a slash in where did we put that in the timer.c so since we're going to rebuild let's go ahead and just rebuild for raspberry pi 4 so we can see that it works on the raspberry pi 4 too i like to swap back and forth so that we can see the codes running correctly on both boards here so let me go ahead and put this sd card in the raspberry pi 4 let me boot it up here we go exceptional one and then we're there we go every one second you'll see timer one received
(12:21) so that's a good start let's go ahead and we can actually use another one of these timers as well so if we look at the list here timer 1 is usable timer 3 is usable 0 and 2 are actually used by the gpu internally so we can't really play around with them i've tried messing around with them it just doesn't work i didn't get any serious errors or anything just with with no reason it's just not working so let's go ahead and call this one interval to actually interval three so it's consistent with our timer
(13:01) i'll just copy this and change all these ones to three essentially okay so we have the initialize done for three and we'll add another handle timer three and again just change all these ones to threes here okay so now we have the handle let's go ahead and add that to our header file and so now in our enable interrupt controller where we added cesare q1 we also want to add three and a handler as well okay so now it should be ready to run
(14:06) but let's actually go and change this interval so instead of every one second let's make it you know every quarter of a second so we should see roughly four of these for every one of those so we should see timer three received four times and then timer one received roughly it might be off a little bit but it should be about that so let's make clean we'll make this one on pi 3.
(14:42) okay let me put the sd card here in the raspberry pi 3 and boot it up let's go to our console and there it's booting up there you see three three three one you see a bunch of threes all right so let me just stop this so you see there's a bunch of threes and then one four threes one four threes followed by one so here here we show we can have two sets of timers if if so we need to use more than one so that's now let's move on to actually creating a sleep function and for that we can use these high and low bit registers here are not
(15:32) high and low bit but high and low words so at zero four and zero eight we have the high and the low so the system counter is lower 32 bits and the system count is higher 32 bits this is just a 64-bit counter of how many clicks it's been since the pi booted up so and we've already added that to our structure so let's just create a little u64 timer get ticks so this function will get the number of ticks since the raspberry pi booted up so first we want to get the high which we can get from timer counter high
(16:16) and now again we'll do the same thing to get the low counter low now there can be one issue if we read the high first and then read the low so i'm gonna do a double check if the high actually changed after we set it let's go ahead and just grab those values again it could be a rare occurrence but it might happen so let's say so if high is not equal to that high value so it's changed between there let's just take these and we'll we're going to grab it again and this is just being cautious
(16:56) so what are we going to return here we're actually going to take these two 32-bit values and change them into a u-64 so first we'll take the high h i shift it over by 32 bits and order order it with the low so now we'll have a u64 out of those two 32-bit values so now with that we can create a simple sleep function we'll just call it timer sleep and we'll take in u32 milliseconds just add a comment because ms some people might think it's microseconds but in this case it's milliseconds
(17:39) every one tick is going to be a microsecond but we want to do it at the millisecond level so first we're going to get a value start which we grab the start ticks so now we essentially want to just loop while get ticks is less than our start value plus the milliseconds times a thousand because they're microseconds by default i'll just put an empty section here so that should be enough for us to do a a nice timer sleep function so let me just copy that and put it into our timer header first now you need to include common
(18:24) because i'm using u32 there and i might as well add the u64 timer get ticks as well now let's go ahead and use those in our kernel.c file i'll just say right after we log the exception level let's say we'll print out sleeping for 200 milliseconds all right we'll call timer sleep oh yeah let's include the header here all right timer sleep there we go and 200.
(19:10) let's do that a couple of times just so you can get a feel for how fast it's actually working so now we'll sleep again this time for two seconds so we'll make that two thousand we'll do that twice and then we'll sleep for five seconds actually this is two seconds two seconds and five seconds and then we'll just put a little done print message here all right let's rebuild let me stick the sd card back in here there we go all right so let's put the card back in the raspberry pi and boot it up here and there we go oh let's let's remove
(20:07) these timer received messages gonna make it hard to read so for now i'm just gonna comment these two lines out that way you can actually see our print messages that'll keep the timers running it's just we're going to not have to see all that extra logging all right let's put the card back in the raspberry pi open up our console there you go sleeping 200 milliseconds and then two two five and you can see it's roughly two seconds and roughly five seconds so there you go i think that's a good
(20:50) stopping point we got to see how this uh how the timers work and how you can use those actually let's make make this for version four two just to double check here we go and i'll put it into the raspberry pi 4. all right move these cables over put the sd card in and we'll go ahead and boot it up switch to the console here we go and there you go sleeping two sleeping two and sleeping five and done okay again i think that's a good stopping point we've learned how to use the system timer interrupts and create a simple
(21:44) sleep function so we can sleep for a specified number of milliseconds i hope you enjoyed this video i really enjoy playing around with the raspberry pi at the low level and sharing my experience with with you if you enjoyed this video and learned something from it please please like and subscribe to the channel i have a lot more content coming up soon and please comment with anything you'd like to see covered in this series i think in the next video i'll start working on a simpler simple scheduler or possibly
(22:16) some memory management and thanks again for watching
