Raspberry Pi Bare Metal Tutorial - Part 10 (I2C) - YouTube
https://www.youtube.com/watch?v=sQdBa-uIHmQ

Transcript:
(00:01) hi and welcome to the low level devil channel today we're back on the raspberry pi bare metal series many of you have requested a demo of how to use the i2c or i squared c protocol so that's what i'm going to do today if you aren't familiar with i2c it's a serial communications protocol for communicating with devices many devices support this protocol from a wide range of uses everything from memory and storage to sensors and displays so if you want to use any of those any of those kinds of external devices
(00:36) understanding a serial communications protocol like sbi or i2c is important so if you want to know more about the low level details on how i2c protocol works i'll put a link in the description to a good video overview we won't really need to know those details to use the raspberry pi because it has a hardware implementation of the protocol we just need to interface with that hardware using its memory map registers now since i2c is a protocol used for communicating with external devices we're going to need an external device
(01:09) to connect to since we're just getting into understanding how to use it i'm gonna try to keep it simple and we'll use a simple uh our arduino script and that that'll create a slave device an i2c slave our raspberry pi will be the master so i'm gonna be using an arduino nano to run this on the script should work on an arduino uno or a nano i'll put a link to where you can buy one cheaply in the description if you don't have one already the connection between the raspberry and pie and the arduino is very simple
(01:46) simply connect the gpio2 on the pi to the a4 pin on the nano then connect gpio 3 to a5 and then connect a ground pin from the pi to the nano so now let's get started on the code so first we're going to open up the bcm 2835 data sheet into the bsc section which is the broadcom serial controller and this is has an implementation of the i2c bus interface and there's more details about it in here if you want to know more about it but essentially it's a memory mapped device so as you can see here it says it has
(02:27) eight memory map registers and there's three different uh buses bsc zero one and two and we're gonna be using one which we need this address eight zero four thousand appended to the end of our base address so you can see here we have a control status data length slave address fifo clock divider data delay and clock stretch timeout so those are the eight memory mapped registers we're going to need to operate with and if you scroll down here you'll see more details about each individual register what all the
(03:04) different bits um setting and reading will do on each of the registers like you have the error here rxf so these are all the different bits on the registers that we will be interfacing with and data length register is pretty straightforward and obvious so let's go back here i scrolled up too far yeah so let's let's actually map this into code so first we're going to create in our peripheral section we're going to create a i2c.
(03:40) h file start of course our pragma wants include the base and we'll include common header so now let's start with a struct for those registers and the very first register was control then we had status data length you have slave address the fifo the divider and we have a delay value we're actually not going to use all these let me see what's that last one clock stretch timeout so we'll just call it let's see call it clock stretch we only need to use a few of these actually so and now we're going to actually create
(04:42) an define just like we did for gpio and the timer and irq so this is just a reference to our registers from the base memory address p base plus zero x zero zero eighty four thousand which is what we got from that data sheet now we're also gonna take some defines here i'm just going to paste into here these defines are just going to be the different bits to set so bit 15 for the i2c enable if we look at the individual registers we'll see here bit 15 is the i2c enable and inter and tt you'll see we have one
(05:30) for each of those these are just defines to make it easier for us to know what we're doing instead of just putting random bit shifting around in our code so now let's create an i2c header in the main include section this will be our actual interface that the kernel will use so again we include the common age so we'll start with an enumeration this is going to be the status these are different status values that i2c can return when we send or receive a command so the first one we're going to call it
(06:12) success then we'll see an ack error which is acknowledge error and then let's say data loss if data was missed then we're going to have a clock timeout i think that'll do it for those so now defining the interface the first thing we're going to do is init so that'll initialize it then we're going to have an i2c receive which will take in a slave address um a pointer to a byte buffer and then the size and it returns that i2c status value and we're gonna have pretty much exactly the same thing with the
(07:00) send it'll take an address a buffer and a size okay so that's our simple interface for it now what we want to do is create an implementation so we'll create a i2c.c this will be the implementation of that protocol so i'm going to copy and paste our interface into there first of course we want to include it we're going to include gpio.
(07:36) h because we'll need to use the gpio include our peripherals i2c our main i2c header and let's also put a printf in case we want some debug statements now i'm going to define the actual speed of i2c that we're going to use and we're going to use the 100 megahertz version so it's 100 000. paste these values in here and we can get started on the implementation now to start on this implementation i'm going to go to the alternative function assignments section of the data sheet you can see here we have sda0 and scl0
(08:22) that's for the very first bsc but we're using bsc1 so we want these gpio 2 and 3 and they're using alt 0 for both of those so those are the two different function alternatives alternative functions that we want to set on the gpio pins so for two we just want to set that to g f alt zero and the same thing for three then we want to enable those two pins so enable two and enable three and another optional thing we can do is set the speed by default it's it actually uses a hundred thousand so we're gonna set our divisor to the
(09:14) core clock speed divided by our i2c speed and again this is optional just because by default it uses 100 megahertz also that clock core speed isn't configured so i'm going to put it down here in the base dot h and that clock core clock speed is 1.5 gigahertz so i'll just enter that number in here that'll be our define all right so let's go back to the i2c dot c file and yeah all right so we're good with the init function that's all that's needed to initialize i2c so now we want to start on the receive
(10:03) to receive a message from a slave so we'll start with a count because we put in the size we want to count the number of bytes that we're receiving so first we want to set the slave address to the address we passed in the next register we need to set is the control register we need to clear the the fifo buffer so setting this flag on it will clear that fifo buffer next we want to set the status register to clkt ored with essaire ored with s done and now we can set the data length to the size that was passed in
(10:59) and now that that the fifo is cleared we can set the control again this time we're going to set it to i2c enable ored with st ored with read so that's going to get it ready to start reading data so now in order to read data we're going to do is loop while reading the status register while it's not done we are going to then loop while reading this status register again to see if the rxd flag is set which is the read transfer flag and if it is set we want to dereference our buffer plus plus equals the value in fifo but
(11:51) we only want the first byte so we're going to mask it with ff and then increment our count so now another thing we're going to need to do is after that we want to loop while count is less than size and the status um srxd flag is still set because it might have set the done flag already but there's still data to be processed so we just again want to take that same code from there and read read the the bytes off of the fifo now we want to grab the value of the status register to see if everything was successful
(12:38) and then we want to set the status register to done so status equals s done now based on that status value that was returned we're going to return different codes from that enumeration we had so if the s error flag is set we'll return see it was ack error and we'll do else if the let's see there's a timeout once if clk t is set then we know there was a clock timeout else if and no we need to check if the count is less than size then we didn't get all the bytes that we needed to get so then we're
(13:36) going to return that data loss and then finally we'll just return success if none of those passed that's that's it for the implementation of receive and now send is going to be very similar so we'll start with that and actually we want to set a lot of these same register values and we do need a count as well so i'm going to paste these in here couple minor difference let's see these are all the same we just need this read flag gone because we're not going to be reading this would indicate that we're going to
(14:26) be writing so now we're going to actually do something very similar that we did in read while it's not done we want to check the txd flag see if we should be if we can transfer data and if we can transfer data we want to essentially do the opposite of what we did when we read from it we also want to only do this while count is less than size because we don't want to keep reading after the number of bytes that we want to read from that buffer so let's see for this we'll do regs i2c fifo is equal to dereference our buffer
(15:13) plus plus which is essentially the opposite of this and i think that should be it other than checking our success values which we're going to do the exact same thing read the success set it to done and check the values for it i think it looks all in order here so let's see if we can actually compile it so open up a new terminal and call make okay looks like we got an error here type def enum and looking at the enum everything is right so looking at the peripherals header it looks like we're just missing a semicolon
(15:57) there very common mistake now if we make okay now that that compiles i want to give you a quick look at the arduino sketch i'm going to kind of breeze over it because this really isn't about arduino but so at the top we have a wire.h we're including we have address 21 we're using for our slave address a little message here so in our setup we call wire.
(16:27) begin with the address we have on request and on receive and functions that we point to for those the serial begin using 9600 baud in a message so now our receive data while there's data available on the wire we're going to read it and we're using a buffer with s printf to just show what the value of this read this red byte is you know we have a hex value and the character value so that's all it's going to do is just print whatever sent to it another request data essentially we're going to take this answer here which is this just a simple
(17:08) string we're going to send the answer and the stirling of it and we're just going to print out that we sent it and we're going to put a little delay in our loop so now we want to upload that to our arduino and you can actually bring up the serial monitor here just make sure your baud rate is set to 9600 and you'll see the little message there so now that that's ready let's code to this serial interface so we'll start with the kernel we can get rid of a lot of this stuff from the previous left and all these
(17:45) different sleep operations so the first thing that we're going to want to do well let's actually just print out that we're initializing the i2c protocol see initializing i2c okay and we're just going to simply call i2c in it we're actually going to need to include the header though so include i2c.
(18:17) h so now now that we've initialized it let's send some data or actually just read some data so we're going to loop 10 times and call the read function if you remember from the arduino sketch whenever we read we're essentially going to get the data i2c hello back or hello i2c whatever it was so we have 21 for the slave address which is what we had in our sketch and then the buffer so let's see address 21 hello i2c which is nine characters yep nine characters so in our char buffer we're going to
(18:57) read those 9 bytes and set the buffer 9 to 0 so we can print it out and we'll just print out saying that we received percent s and the value that we received from the sketch and then we'll just do a timer sleep for 250 milliseconds so now that we've received data let's send some data to we'll use the u8 d equals zero d is less than 20 d plus plus and we'll do i2c send again address 20 21 and the address of d and then one because we're just sending one and again we'll sleep for 250
(19:46) milliseconds and we'll print out saying that we sent and the value that we sent all right now let's send a longer message we'll send hello slave device so this will come from the master and the slave device should print it out all right so and that's 18 characters so that's the length we're putting in now let's go ahead and run make and it looks like there was an error d oh i put hint before you wait there we go so now it should build i clean and then we'll make and it's all ready to go
(20:36) so now let's test this out okay so now i put my disc in the pi 3 and i'm opening up the screen command so we can see it booting up see we have the received hello i2c 10 times sent zero one two three four five all the way up to 19 and then done now if we look at the itc sketch we can see all that all the logs from there actually let's let's uh clear this and we'll run them together so you can see it a little better so i'm just restarting the pi again now you see sent data sent data oh it's
(21:22) receiving data and then it received that hello slave device and there you have it so now let's uh i'm gonna put some notes here in the code as as well for what the different connections are between the two let's see we have the our pi and connecting to the arduino so we have gpio2 connects to a4 gpio3 connects to a5 and just connect a ground to a ground and there you have it a simple i2c connection between the raspberry pi and an external device and how to control it using memory mapped registers that'll be enough to get us started with
(22:25) i2c possibly in a future video i want to go over connecting to an actual device maybe a sensor or an lcd display but for now i think that's a good intro to the i2c communication protocol for our little bare metal project so again if you learned anything and enjoyed this video like and subscribe and if you have any questions or anything comment on the video or join our subreddit and uh thanks again for watching
