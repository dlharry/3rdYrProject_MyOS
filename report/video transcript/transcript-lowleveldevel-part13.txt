Raspberry Pi Bare Metal Tutorial - Part 13 (VideoCore Mailbox) - YouTube
https://www.youtube.com/watch?v=hSJWbmiQfck

Transcript:
(00:01) hi and welcome back to the low level devil channels raspberry pi bare metal series in this video i'm going to show you how to use the raspberry pi firmware's mailbox interface to communicate between arm and the video core gpu this is a not a very well documented api there is some sparse documentation in the raspberry pi github repository but still very little you can also download the 4.
(00:31) 0 version of the linux kernel to find some code that actually uses this api the newer versions of the kernel replace the mailbox api with some other methods there's still some code in there but i'd suggest using 4.9 as a reference if you want to get deeper into how the um the the mailbox api actually works so let's get started first i'm going to show you where some of the documentation is here in the raspberry pi firmware wiki so you find that on there github paste in the page in the wiki section so there's some information here you'll
(01:12) see that noticing here that the video core is closed source so there's not code in here but there's a little bit of documentation and this mailbox section is what we actually want you'll see that's how you can communicate with the gpu so clicking this link we kind of get a list of the different mailboxes and how they're used so you can read through this some of some of the stuff's documented like that one isn't the frame buffer is somewhat documented there's a little bit of information in that link
(01:47) but not very much honestly property tags section is probably where you get the most but you notice this page is really short so there's not too much so let's click property tags this has some decent information on how you uh you know create a mailbox message um you know what the order that it needs to be in the buffer contents when sending a message and what the request and response should look like so different values for like a success request and an error request and then we have a tag format that has a
(02:29) tag identifier the buffer size and bytes and then some data containing the different codes used and then a set of tags this arm to vc tags so like getting the firmware revision see some other stuff here getting the arm memory the vc memory the video core memory um you know there's lots of different tags and stuff you can send for requests here's one to get clocks so they'll get some data about the clocks and also uh this link down here so see here this gives some information on accessing mailboxes how you actually
(03:19) need to set up these requests and some of the information about it a little bit of a sample code on how you would do something like that so that's kind of where this came from and from some other open source projects as well just researching how they did it such as the circle raspberry pi so what i'm going to do is go into my kernel code here get rid of all this led stuff so that this is going to start our mailbox section and in order to start a mailbox first i'm going to add a header file and and i'm not going to go into detail
(04:01) so this is mailbox.h i'm not going to go into detail too much on where and how i got all this data because since it's mostly undocumented it really took a long time to find all this data normally if there's data available in a data sheet somewhere i'll show you exactly where to find it and how to get it but since this is so unwell documented i'm not gonna bother so first i'm starting here with this mailbox tag as a structure each tag has an id and then it has a buffer size and a value size or value length i'm
(04:41) going to call it okay so now next i'm going to have another structure here mailbox command i'm not sure i'm actually going to use this but this is one way to do it so i can say commando to have a size and a void pointer for the tag information and we'll get more at that later it would be referencing one of these tag objects i'm not again i'm not sure i'm going to use that but for now i'm just going to put that there there's going to be some other types of structures that will need
(05:30) so let's go next onto this one will be the mailbox generic what i wanna call it yeah this will just be like a kind of a generic uh command i don't know if you wanna call it tag generic or just generic so that's gonna contain a tag so yeah i think we'll get rid of that tag which is called mailbox generic so inside of this structure it's going to have a mailbox tag at the very top so that's going to be our tag and then it's got this is a generic one usually has an id and a value so the input is kind of the
(06:20) id and the output is kind of the value sometimes output is in the value is input and output but that's just a generic uh mailbox tag i guess you'd call it so i'm going to create a couple more here actually that this one could be used as a generic one as well but since i know the name of the field if we want to check the mailbox state of a of a power domain so again that could really just use mailbox generic as well but i'll create a specialized one for it not all of them are only only going to have that input and output as u32
(07:08) some of them will have many other fields especially when you get into the frame buffer so this next one is another one that could have been generic i'll just id and rate this is going to be for checking the clock rate so if you want to get the clock rate of your uart clock or your core uh clock and create an enumeration for the different types of clocks so let's see we have clock type as we saw ct underscore i'll make it uppercase ct underscore emmc is the value one uart is value two then the arm is value three
(07:58) and then the core is value four so that'll be your core clock so i'll call that enum clock type okay so i think this is a basic structures we're going to start with next i want to actually take some specific defines so these power domain defines are the mailbox power ids so there's 22 of them or 23 of them actually and i can show you where you find that in the raspberry pi linux firmware.
(08:40) h and that's in our pi 4 9 y stable version so if you actually if you actually look down here it's not this file it's a different file let me i can do a quick search on that if i click this right all right i do a search and yeah here we go so raspberry pi power dot h so i i just copied those straight from there and then there's the count so there's 23 of them maybe i'll take that as well put this down here so each of those are the different values you'd pass in for the id when you're checking the status of a
(09:36) power domain sometimes you need to power on certain domains as they call them or power them off so now i'm going to go back here there's also the in the firmware there's a section for the this is the property status so you got a request value then a success an error response and then here's that tag header this is what they're calling it notice the buffer size and the request response size that kind of maps straight back to this generic one we or no the mailbox tag one that we created the id the buffer size and value length
(10:22) okay so then down here we have the different property tags so that corresponds to the actual tag value so these are kind of the different commands that you can send in through the mailbox api to set up frame buffers and things like that i'm just going to copy and paste that down here too so yeah looking through here there's different commands you can do to uh allocate a frame buffer blank one you know get the pixel order let's see you can release a frame buffer okay set the palette so all kind of operations you can do on a frame buffer
(11:08) that's how you actually use the video state and uh here's some power here's the get power state that's how we would do one of these power commands but actually the newer version is this get domain state actually so we'd use get and set domain state there's a set clock rate so you can change clock grades get clock rates right now we're just gonna implement the getting the clock rates just as a starting point and actually i think i'm gonna take this other section up here i'll take this as well so we can use
(11:48) those i think that's everything we'll need in the header and so now let's move on and create a mailbox dot c so we're include the mailbox.h and there's a couple more headers i think so we'll include the peripherals base.h include printf if we want to print any error statuses and stuff is that it i think you got also we need to include mem.
(12:34) h which is something we need to create we in our current code base we don't have any kind of mem copy functions so let's go ahead and create a simple one so to start with i'll just do the pragma once in our header there comma dot h and so it returns void pointer takes a destination and a const source and a number of bytes so let me create a mem dot c and we'll put the simple implementation for it there so we'll include mem.
(13:19) h paste that in there so we'll call this a really simple implementation if you actually look up the source code for them copy it's pretty complex so this simple limitation we're just going to take two uh byte pointers convert those void pointers to byte pointer so we can just iterate through each byte from zero to n and we're going to set b dest i equals source i and return no return dest it returns the destination and i got something wrong here put a b b source there we go okay now that we're past that
(14:13) now we'll go on to the implementation of the mailbox api so to start with we're going to need to be able to write to a mailbox but uh actually we'll create we have some structures to create first so one of them is the mailbox registers and this is what we're going to read and write from so the first register is a read register then there's five reserved ones a status register a config register and a write register and we'll create a okay function helper function here to just uh automatically return our mailbox regs
(15:05) from the address pointer it's at p base plus 0xb880 okay so next we move on to creating a different struct for uh handing our property data so we'll call this the property buffer so property buffer is going to have a size then it's going to have uh a code and then tags so this will be an array of tags and i'm going to map a uh map it to a u32 property data array so i'm creating this here specifically because we need to use this attribute aligned 16 because it has to be 16 bit aligned according to the
(16:06) specifications that i've been able to find on these uh mailbox requests so now that we have that we can start implementing the mailbox write function so it's going to take a channel and then data to write so the first thing we do is we need to loop while the status register has the mail full flag set and all we're going to do is just loop indefinitely while that's set and we don't have mail full yet let me find that yeah i'll actually define this as male full as 0x 8000 and the male empty is 0x
(17:07) let me put a space there to line this up 0x4 with a bunch of zeros all right so that's what we need to do there so now after we know that it's looping while it's full then we're able to write so what we're going to do is take the data the full data section except the last half byte and then we're going to order that with the channel but just the last half byte of that so that the channel is the last half byte of the data that gets written so that's the data section and that's the channel
(18:04) okay so now let's move on and we'll do the static ant mailbox or sorry static u32 mailbox read because we're going to actually read data from a channel so this is gonna be a blocking request so while true it's going to check the status if the mailbox is empty then it's just going to do nothing because there's nothing to read otherwise it's going to grab some data so calling read and remember the bottom uh half bit half byte of that is the channel so we're going to mask that to get the
(18:57) channel and if the channel on that read is the channel that we want that we're trying to read from then we're going to return the data but again only those top bits okay and there's nothing to return here i guess this is just gonna block indefinitely until we find data on that channel so yeah and then it's gonna return it masked with the data section all right so now we can move on and we'll have a function called mailbox process this is gonna process a mailbox tag so it's gonna take the tag in the tag
(19:52) size so the buffer size is going to be the tag size plus eight plus four and that eight and four trying to remember where that comes from yeah let me change that that should be size i believe that comes from down up here so the id and the buffer size and the value length so that's yeah i think that was when i was going to use command for maybe the void pointer plus that size but anyway we can say that's 12 because of course he's plus 4 is 12.
(20:47) all right so we have the buffer size now we need to mem copy the property data plus two because we don't want to start at the very beginning we need to start at byte number two or the word number two you can also write this as and property data at index two so either way it'll work so then we wanna copy to the tag or from the sorry i'm going to copy the data from the tag to the property data for tag size and yeah so here's here's actually our size code and then the tags that's why we're saying because we're
(21:35) mapping this to the property data section so that's why we're starting at the second one because size and code are passed over and we're copying the tag data to the tags section hopefully that makes sense to you so now we're going to create a property buffer variable in which we're just casting that property data to the property buffer already and now we want to set its size so the size is going to be the buffer size and the code is going to be with that request let's see yeah rpi firmware status request
(22:30) so that's the code that we're going to use for sending a a mailbox firmware request all right so now what we need to do is set the property data now we want to get the tag size plus 12 remember that 12 that we added now we're going to divide by 4 because this is a u32 that's a youth 32 array so we're dividing that byte size by four and subtract one it's a little complicated i know but the very last byte needs to be this property end value so we we have all the data in that property buffer and then it
(23:24) knows that it terminates when it reads that property end value which is zero okay so that knows that's how it knows when it's there's no more property tags for it to read by finding that property end tag so now we can run mailbox right and this is going to say mail tags which that's not defined yet off to define that so mail tags i'm going to pass property data that's the data we want to write to the channel mail tags and that's a u30 we need to cast that as a void pointer to u32 okay okay now i'm just gonna
(24:30) go up here and paste these in these are the this is just some defines for the different channels i'll put it right down here so you have the male power mailbox power channel the frame buffer channel if you remember that one document it showed those different channels and the tags one is the one that we're really going to care about because that's where sending these tags to communicate from arm to vc so arm to vc so now that that's okay so we're doing mailbox right and every command is a mailbox right and
(25:15) a mailbox read so this one actually doesn't return anything i should just make that a void yeah i'll make that avoid so for mailbox read we can just do oops u32 and we'll call it result i suppose so the the result is going to be mailbox read and mailbox tags so that's what we need to read from and let's see so now that we have that data we need to copy the property data plus 2 again a tag size into the tags because when we uh we want to give it back to the calling structure so you pass in that that tag
(26:21) then you uh write it and then you read it and then copy it back into that tag structure from the property data hopefully you're uh following that and looks like there's no chance of failure here so i'll just always return true you can probably end up making this a void assuming it's always going to return true i don't like that idea though so next we'll have a mailbox generic command which will take in tag id an id and a pointer to a value so that we can use it for output so if you remember we had that mailbox
(27:14) generic structure this is going to be a simple way to call that mailbox generic structure so we'll call this mailbox generic mbx we'll say tag dot id equals tag id dot tag dot buffer size or actually value length we set to zero because that will actually come back for us when it's returned so now tag buffer size is equal to size of our mailbox generic structure minus the size of the tags because the buffer is really only the data after the tag so then we'll say id equals id and value equals dereference the value
(28:22) so now if not mailbox process let's see and we'll use the tag now we need to cast this mailbox tag remember remember the very first item in this mailbox generic is the tag so it's safe to cast this to a mailbox tag and size of mbx i think we're missing the there you go okay so now we'll print f fail to process and then present x and we'll put in the tag id and we can just return false and then finally after we know that succeeded we can just dereference value equals mbx.
(29:18) value and we can just return true okay so that's how we'll invoke a generic command we can do a more specialized one as well maybe we'll add one for the clock interface yeah so let's add one for the mailbox clock so to start there we're going to create a new function down here this one will just return the value so u32 mailbox clock rate will take in a clock type and this is going to work very similar to the mailbox generic so this is going to be mailbox clock um yeah just mailbox clock and we'll just call that c i guess
(30:13) that's probably fine so we need to set the tag id and this one is specific to our pi firmware get clock rate notice there's a min and a max as well so you can get the minimum rate and the maximum rate so we'll set the value length to zero again the buffer size will be size of c we can just use the minus size of c dot tag and then we'll say c dot id is the clock type and we don't need to set the value because that's an output parameter for this uh specific tag and let's just invoke mailbox process we
(31:17) know it doesn't fail so we'll just invoke it like this so again cast it to mailbox tag pointer and see sizeofc and we'll return c dot rate so that's going to give us the clock rate for that clock type okay so that's a simpler api than the generic one since it's specialized to the uh clock types and you could implement a max and a min as well for now i'm just going to keep this simple as one small one let's create another one we'll call it bull mailbox power check so if we want to
(32:08) check the power of a certain power domain the bull will be on or off so we'll say mailbox power uh we'll just call this p we're kind of kind of do the same thing i'm just going to be lazy and copy and paste here hope i don't mess anything up so p p p change up to p just to p and that to p and type there and then this will change so this will be our pi firmware get domain state okay and on this one we actually do have to set the value this the state as tilde zero because we need to check the value check against the value at
(33:08) least that's what the the raspberry pi linux code does there's no documentation on that it must do this but that's what they're doing in the linux kernel then that's what i'll do so again mailbox process pass that in size of p and now for here we're going to return so if p dot state first bit is set then we know that it is on but also we need to check that p dot state is not equal to that tilde zero so they inverted zero so then because otherwise that means it failed apparently so i think that's all the code for the
(34:01) mailbox.c so let's go into the kernel and start working on calling these apis all right so now back in this section underneath the spy in it i'll just start by writing some let's see we'll just say this is a mailbox section and let's see i think i'll print out some of the different clock values so we'll say the core clock and we'll call mailbox clock crate and it looks like i didn't put that in the header i'm going to have to add that um all right mailbox clock rate there's probably a few things i need to
(35:04) add to this header i want the generic one for sure all right so i'll just copy the mailbox generic command and i'll put that in mailbox.h as well maybe that's enough for now because i don't need process read or write don't need any of those in there that should be good let me save that and go to the kernel i need to include that header as well we'll say mailbox.
(35:59) h so mailbox clock rate and it'll be ct core okay yep that's all i need so i'll print each of these four so we have the core the emmc we have the uart and the arm so ctmmc ctu art and ct arm yeah okay so let's also do these power domains let's see the first three power domains of the i2c 0 i2c 1 and 2.
(36:51) so let's check the state of those three so i'll say the i2c power state so i'll go from zero to two and let's see we'll print f i want to print the value returned mailbox power i think i need to add that to my header file as well so let's go back to the mailbox dot c at the bottom yeah power check okay paste that here and let's see power check we're going to check the power for given type actually we don't need that to be an if statement let's
(37:57) just say i'm going to say bull on equals mailbox power check and pass in i as the parameter now we can just print out we'll say power domain state status for percent d equals percent d so the first one will be i and then the on status so that'll tell us those first three what their power domain status is i should probably show how to use generic as well so let's do a simple one for that we'll do let's get the max temperature and we'll just call mailbox generic
(39:04) command it's going to be our pi firmware get max temp temperature there we go and zero for the id and address of max temp for the output so that'll give us the maximum temperature inside that variable and you know we'll do we'll in this while loop then we can check what the current temperature is so we'll do that inside here now we're actually doing something at the end so we'll call this cur temp we'll just take this same thing remove max from here because we're just going to call get
(40:01) temperature and cur temp then we'll print out what the current temperature of the cpu is so max percent d so we'll say cur temp and max temp oh and we want to divide by a thousand because the value it returns is actually a higher higher value so dividing by a thousand will give us the actual temperature that i just saw in the linux code as well because it was returning high values so i looked it up and they're dividing by a thousand so then we'll just sleep for a second so every second we're going to check the
(40:54) current temperature so now let's go ahead i'm going to put the card in i need to mount it first let's see mount it now we can go ahead and build make clean and make okay now built successfully so i'm going to take the card out put it in the raspberry pi 4 and we need to run the screen command to check the output all right it's starting up and you can see there's our different mailbox clock values you see the power domain status four zero one and two as well so these are our different clock values
(41:50) power domain status 0 1 and 2 is 0 1 0. so this i c i 2 c 1 is on but 0 and 2 are off and you can see the temperature currently 30 start at 32 now it's at 36. i'll leave that running and we do some changes here so i'm going to copy and paste this loop a couple times let's actually turn those on so i'll do a timer sleep say two seconds maybe so and then a timer sleep for another two seconds and just one second just so we can see it as it's going on so this will we'll say set power domain
(42:41) status four percent d to percent we don't want to do power check anymore we can do this the generic thing if you remember we had the uh generic command we and there was a let's see there was a set power domain state as well so let's call this generic will be and we'll create a e32 on equals zero we'll say our pi firmware set and i think it's domain yep set domain state and we want to put i there because we're going to set the state for that specific one and we want to set it to on which is one
(43:41) get rid of this so essentially we're going to check the statuses set the statuses to one for all three and then check the status again to make sure that the actual values got set so yeah this will be the check this will be the set and then this will be the check to make sure the set completed so let's go ahead and run that i take the card out i need to remount again actually look you can see this is still running it's currently at 44 celsius well while i'm waiting for that card to load up just watch it it's changing 44
(44:30) 45. i actually put a little piece of ice on it i have a whole piece of ice in my drink here see look at drop 30 c 20 c 26 30 31 i touched it with a little tiny piece of ice for my glass you can see the temperature dropped significantly after that so that's pretty neat okay so let's go back here i don't suggest doing that because you could probably damage your raspberry pi if you get water on it but i was pretty careful so let me go ahead and make that again all right and i'll take the card out put it back in the pie
(45:20) so let's take a look and see what happens when we run this so i'm going to unplug it and plug it back in all right it's starting up there's our statuses zero one and zero setting them all to one get them again and now they're all one so they're all set on so we did a get a put and then a get again so i think that's probably a good stopping point for this video i think in the next video i want to start showing how to do the frame buffer stuff that's how we'll be able to actually
(46:05) output to hdmi so it's the same way that linux used to use the frame buffer api for for displaying to hdmi output and that gets pretty complicated so it'll be might be a long video as well so i hope you really learned something from this this is a kind of useful api especially if you're doing bare metal stuff so if you did learn something from it again like share comment subscribe and all that and thanks for watching
