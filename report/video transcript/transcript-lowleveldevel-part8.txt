Raspberry Pi Bare Metal Tutorial - Part 8 (Interrupts) - YouTube
https://www.youtube.com/watch?v=nUW1FB_5vqo

Transcript:
(00:01) hi and welcome back to the low-level devil channels raspberry pi bare metal series in this in the previous video we implemented the process of booting our kernel into exception level one now i want to get started with handling system interrupts so let's get started first we will create a header file entry.
(00:23) h which will have some of our defines related to the different exception types that can be configured in the interrupt controller so we'll start with our pragma once so this is going to be in section d1.10.2 the arm reference manual here now when an interrupt occurs execution is forced into an address that is the exception vector for the exception the exception vector is in a vector table that is specified that at the specific exception level that the code was running in and each of these exception levels has a virtual base
(01:03) address register which defines the base address for the table the exception level and has each of these four possible types synchronous exception s error irq and fiq and there's one for each of the exception levels so i'm just gonna paste in some of these defines here this is for el1t we have sync irq fiq and error so we also are going to have this for el1 h as well you'll see here is el1t and here is el1h so we'll have actually four sets total we have those two and then we have one for el0 and 64-bit
(01:46) and one for el 0 and 32-bit so in all there's 16 specific different types where we can handle our exceptions now let's go and create a new file here we'll call it entry dot s and this is gonna be the assembly code where first we're gonna include our entry header so now we're going to set up this vector table and what i'm going to do is just paste this in here first we have to have an align here and we have our global vectors variable our position that we're setting up here so you can see we have each of those four
(02:29) values here and then the four different sets for e01t el1h el 064 and el032 and we're using this vnt macro here which is actually one we're just going to create it's a really simple macro so all that it's really going to do is take in a label and jump to that label so we're doing a branch to that label we're using a line seven because it's a requirement on the size of each of these uh exception vectors so now we're branching to these labels but where are these labels exactly well i'm just
(03:14) going to paste them down here we have one label after each v entry so we just want to paste these locations down here so we can jump to them when we receive one of these interrupts you'll see we got the entry sync air here goes to here which calls this handle and valid entry passing the sync invalid el1t which is straight from our entry header file here so that's where we're actually using these defines then we have one for the next one and then and so on if iq and error so when we and this is the one that
(03:54) we're going to actually care about here the handle el1 irq because in that one we're actually going to have a handler for it which um okay i don't have that here yet it looks like we'll worry about that one later so basically what i want to show you here is we have this handle invalid entry method here or assembly function that's a macro actually so we pass in type and that calls another macro called kernel entry which we'll get to a little bit later but essentially what it does is it's
(04:32) going to pass three parameters first the type into x0 then the esr el1 index 1 and the elr el1 into x2 and then it's going to branch to this function show invalid entry error message which we'll write in the c code and then it's going to jump to this error hang where because if it received an unknown error we can't really do anything but just hang it so we'll just paste this little error handler down here which is essentially going to loop forever so now here is our handle el1 irq which when we get an actual irq that we
(05:14) want to handle we're going to jump down to here and this is essentially going to call the kernel entry handle call our handle method and see and then kernel exit so now let's get into the details of what this uh kernel entry is gonna look like now essentially what we want to do is before we when we get an exception we're jumping outside of our regular context so we want to store the state of the processor before we do anything and one thing we're gonna have to use is our stack frame size which is 256 right here
(05:58) so the the very first thing that we want to do let's end m here yeah the very first thing we want to do is subtract from the stack pointer the value s frame size so that we're doing this to make room for the variables we want to store on the stack so we're going to use the stp we'll use x0 and x1 the stack pointer offset by 16 times zero which of course is zero so we jump back the frame size and now we start storing so we'll do the same thing for x two and x three and now we're gonna go by the stack frame with the offset of
(06:45) 16 times one so we're essentially going to do the same thing for all of our registers store all of our registers four five six seven eight nine and so on up to thirty and again we're uh every time we do we're incrementing by 16 which those all add up to this stack frame size with a little bit of room to spare so so basically you're jumping back storing our variables and then we're going to use the kernel exit method which is essentially going to do exactly the opposite so we're going to ldp x0 and x1
(07:31) stack pointer 16 times 0 and then the exact same for x2 and x3 16 times 1. and we're going to do this for all of the registers again and then at the end we're going to add the stack pointer back to that uh that s frame size and use eret which is going to return us from the exception so this is you know you can see the first thing we do is we want to store the state call our method and then restore our state that's the whole purpose of this kernel entering kernel exit macros so now let's go and create a irq dot s
(08:20) file so we can actually use these exception vectors and this is going to be in section d 13.2.137 so i'll open that up in the reference manual here you see we have v bar el1 so this is just some information about the vector base address register here so this is again useful information if you just want to read through it some to get some extra information and context here so we're going to create our global method we're going to call our function we're going to call irq init vectors so we're going to use adr x0
(09:07) vectors storing the address of vectors into x0 that's this vector's value that we created here so we'll store that value into x0 and we're going to use msr to put that into v bar el1 and then return so that's going to uh set up our vectors so now let's look really quick in c5.2.2 in order to enable and disable our vectors we want to use this register here d a i f it's a daif interrupt mask bits so in this daif have special meanings d for debug yeah we have a for the asynchronous s error interrupt mask
(10:03) i for i r q and f for the fast irq so in and you'll see here in the register we have d a i and f as individual bits so those we would be able to set and reset to enable and disable these different functionalities and so for enabling the vector we're going to create a i'm sorry enabling the interrupts we're going to create a function here irq enable and all this is really going to do we're going to use msr on daif clr that's going to clear a bit number two so in a bit number two we have f is one
(10:50) and i is two so clearing that bit is going to enable the irqs now we'll simply just return from here and we're going to do the same thing for irq disable so we have irq disable and the only difference here is we're using di daif set so to set that bit is going to disable it so now let's uh create a little header file and put these functions in it q.
(11:40) h let's make sure we copy these names correctly so we have the irq init vectors and these are going to be called from our kernel code so that's why we just need to put them in a little header here so they're easily accessible so and that's that's the initial part for setting up these irqs now let's get into how to use these irqs we'll create a irq.
(12:24) h under peripherals here and first let's take a look at the well we need to include these common things first and then we'll take a look at the data sheets here we'll start with the 2711 for the raspberry pi 4. we have this section of our irq pending registers and this is at you'll see b000 as as the base so we start with at 200 offset 200 we have irq 0 pending higher q1 pending that's 204 at 208 we have ir cube 2 our eq pending 2 then we have it 10 we have set enabled and then we have the irq set enabled one hierarchy zero set
(13:23) enable two and then the same thing for clear enable zero enable one and enable two and so the addresses here you'll you'll note are similar to the raspberry pi 3 but the raspberry pi 3 has a little bit of a different order here so if we scroll down here we'll see 200 we have the basic pending which is irq pending zero is the same thing same address so 200 is the you know pending zero 204 is pending one 208 spending two then we have this fiq control which we didn't have there and now we have irq enable one two
(14:11) and then zero and disable one two and zero if you remember the other one instead of one two and zero we had zero one and two this one is still zero one and two and both but the enables zero one and two clear zero one and two whereas on the raspberry pi it's it's one two and zero and one two and zero so we'll have to create different data structures for those two so that they don't conflict so let's go here and just start by creating a structure here for arm irq regs we'll say 2 7 1 1 so this will be the one for the
(15:00) raspberry pi 4. start with a reg 32 irq 0 pending 0. iq 0 attending one and then again irq zero pending two so then we have a reserved spot here that's not used and then we're essentially going to have the same things here so let's just copy and paste this will make uh let's see we'll make this enable zero enable one and enable two and then another reserved variable and likewise we're going to have this same set here for disable
(16:09) so that's going to be the basic structure of our irq registers at least the ones that we're going to be currently using so let's see go back here to let's create one here for arm irq regs 2 2 8 3 7 so this is the raspberry pi 3b and this is essentially going to have all the same values so let's just copy everything we'll start with this one after those three it's going to have the fast irq control and then essentially it's going to be all these same values here it's just instead of 0
(17:02) being first it'll be third so put those right in order and this is just reserved so now we have essentially the same registers that we're going to use and now let's create a define or actually we're going to create some type defs here so if we're in raspberry pi version 3 we're going to type def struct arm irq regs as our arms irq regs 2837 as arm irq rex and then we'll do the same thing for four except we're going to use 2 7 11.
(17:52) so now down here we'll actually def make up define to this pointer that we're going to use rmi or q regs from p base plus zero x zero zero zero e two hundred so that's the uh variable that we're going to use to actually access these registers so we'll go back into the data sheet here and what we're going to do is jump down to the irq section and this shows the different irq 0 to 15 16 to 31 that we're going to be actually using what i want to focus on here is this aux interrupt so this if you remember aux is how we get
(18:43) access to the mini uart so what i want to start doing is working on a way to capture interrupts from the uart instead of looping in our normal while loop we're going to receive the updates as interrupts so first let's create an enumeration here we're going to use the we'll call it vc irqs that's for video core so we're gonna have aux irq equals one shipped over by 29 because that was the 29th bit in the uh irq list so now let's go on into our where are we going let's create a new
(19:30) file here called irq.c so we're going to first include our utils include some of our other headers here let me print f our entry dot h see we'll need our peripherals higher q and peripherals aux we'll probably need the mini uart as well so let's start off with adding the definitions text definition map here for each of these invalid types so these came straight from our entry.
(20:19) h header again each of the four sections so this is going to be just for some print friendly uh names for them so we want to start by using our handling invalid handle and valid entry let's see yeah handle invalid entry so we'll start writing the actual function remember this is taking three parameters here the type the esr and the elr and it's passing to this function show invalid entry message so we're going to create that function show invalid entry message it's going to take you 32 type u64 esr and another u64 the address
(21:08) which is in that elr register so it's going to be a pretty simple printf error cot we'll do the string the type and the esr value as hex and the address as hex so pass in our function our uh char array map here and index type then type then esr and then address so this will print out this data whenever we hit an error so now let's start with enabling the interrupt controller so to enable the interrupt controller we're going to have to do something
(22:14) different on each of the boards so for the rpi version 4 we have a specific register we need to use and use regs irq irq zero enable zero that's because if you go through the data sheets the zero through 32 registers are on that enable zero and we're going to set it to a ux irq because that's the only one that we're using currently and so for the raspberry pi 3 it's actually the enable one register a little bit confusing but the two boards are they're different they're different interrupt controllers
(22:58) so now we'll just handle our handle irq method so on this one we kind of have to do the same sort of thing here each of these has a different register that it picks the actual irq from so for the raspberry pi 4 it's irq pending zero and that's we need to create a variable here so u32 irq our q equals that i keep pending zero and then for the three it's on the pending one so now now what do we do with this irq so we know that we got one well it could be multiple to start with we only have one but for
(23:59) right now we're going to say while it's of an actual valid value we're going to see if the aux bit is set or hold on that's uh yeah under q and equals and so it should be a ux irq higher q and equals the inverse of aox irq that's so we can just loop and remove the the bit that we've already handled of course right now we only have one so it doesn't matter so much but let's jump back here and let's look up the mini uart registers again so we have this muir register so this is the one they're gonna we're gonna be
(24:51) concerned with here you'll see it has on bits two and one we have a receiver holds a valid byte so we need to check does the receiver hold a valid byte so that would be the value one zero but at offset two one so that's going to be four if you imagine you put a zero after that would be 4 in binary so if that 4 bit is set on the muir while an4 is equal to 4 then we know that there is data to be read so we'll just print f uart receive and then we'll just here just do a uart send uart receive and then we'll print a new line
(25:54) so that's that's what's gonna happen whenever we get the iar register showing that there's data to be read so now let's go back up here to the i air register this is how we're gonna enable the uh aux mu interrupts so if we look here we have enable receive interrupt is bit 1 so if this bit is set whenever whenever the receive f uh fifo holds at least one byte so that's the value we want to actually set in our mini u art when we're starting up regs aux mu i air equals two so now let's jump back into
(26:48) our kernel and we're gonna copy this function first enable interrupt controller make sure that's in our header jump back into our kernel here and we're going to include this irq.h here and then after our initializing of printf and uart we're going to call this function enable interrupt controller then we have the other functions such as let's see irq init vectors um see that one we actually call first so init vectors then we'll call irq enable to enable higher cues now we're gonna take this part out here where we
(27:36) normally send and receive just in a loop so we'll just loop continuously doing nothing and let's uh go ahead and build create a new terminal here make clean make for our pi version three while we have an error let's see um okay yeah that's just because we forgot it's irq zero pending zero and rq is zero pending one make again all right so now let's put this in our raspberry pi three jump back over to our console here now it's booting up and okay so it started up so now i'm typing here these are just the different
(28:28) letters that i'm typing this is a test you can see that all works as expected it looks pretty good for raspberry pi 3. so let's jump over here and we'll do raspberry pi 4. so to make clean make our pi version of raspberry 5'4 all right so we'll take this sd card and put it in the raspberry pi 4 here and jump back over to the console i'm just going to move these cables here all right so here we go to the console and you see it's booting up there we go except for level one and as i'm typing exact same results
(29:23) so so it looks good so i think we're at a good stopping point this has been a bit longer than the other videos but i wanted to make sure you understood how to initially set up the interrupt controller and the section vectors all together and actually use the irq for the mini uart in this in the next video i'll show you how to use the irqs for the system timers and with that we can create an accurate delay function using the system timer interrupts once again if you enjoyed this video and learned something from it
(29:58) please like and subscribe and comment with any questions you may have thanks for watching
