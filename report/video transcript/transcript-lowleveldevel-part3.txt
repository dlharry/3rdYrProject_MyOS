Raspberry Pi Bare Metal Tutorial - Part 3 - YouTube
https://www.youtube.com/watch?v=36hk_Qov5Uo

Transcript:
(00:01) hi and welcome back in our previous video we continued on with some of the code for the shared functions started with the kernel hello kind of code and the boot process and we also started um integrating with the auxiliary registers so that we can invoke the uh methods needed for handling the mini uart function in this video we're gonna start off with the gpio related code and probably finish it up before we continue on to actually using the mini uart code so let's get started with the gpiro related code
(00:40) first we'll open up the datasheet here we'll see that the gpio related information is here section six so let's scroll on down to there and here we have the section here gpio general purpose io nice little diagram that shows how it's set up and down here we have the registers you can see they start at seventy twenty zero zero zero and the first set here you can see are the function select registers followed by a reserved and two registers with pin data for output and then the same one i reserved and two
(01:26) registers with pin data for output clear and then the level event detect rising edge detect on all this same pattern of reserved and two following registers goes all the way down to the clock pins so let's go on over here to our code and we can start setting up this structure first i'm going to put my common header of course and our peripheral base so let's see first i'm going to create a struct uh called gpio pin data which will kind of model that structure of a reserved register followed by two registers with pin data
(02:16) and those that will just make that an array since it's always two and we're going to use that in our main gpio reg struct here so at the top we actually going to have a set for our function select and we had six registers i believe that's all you can ignore that first one it's just duplicated so we have zero through five and then followed by that we have this struct gpio pin data for our output set section see right here output set then we'll have an output clear and we'll just go on and model each of
(03:05) those here so output clear level event detect status our rising edge detect enable our falling edge detect enable our high detect enable and our low detect enable in our async rising edge detect and our ac async i spelled that wrong async falling edge detect so then we're going to have this reserved register here right before our pull-up pull-down related information
(04:12) we have our pull-up pull-down enable and then our clock zero and one clocks and we're going to make that an array too since it's two of them and let's see we need to get the address for this remember starting at 70 twenty zero zero zero so we just need the second half of that we're gonna again create another define just like we did for the auxiliary registers i'm gonna create a pointer to our main struct here from the p base address plus that value zero zero two zero zero zero that will be how we access the gpio
(05:11) registers so let's create some user headers here let's go back to this mini uart our gpio registers here go back down to our gpio section remember we had these function selects here so what we want to do is kind of look at the values for the function select so you know the the first the top two bits are reserved but then we have these f cell nine which shows the different values for input one for output one zero zero for function zero one two three four and five the values
(06:14) aren't in order so you'd kind of expect them but you can see that's also repeated for each of these so we're essentially going to have 10 pins controlled by this one register the first pin is going to be bits 0 to 2 then 3 to 5 then 6 to 8 and so on so this will actually control a total of 10 registers and then we have another one for the next 10 registers and then the next 10 registers and so on so like you can see we have these this is how they're all going to be set up for each of those for each set of
(06:54) pins so let's create a an e number enumeration here for those values first uh first we want to pragma once include our comment our peripherals gpio that'll already include our common so we're going to create a enum here we'll call it gpio func this is going to be the different gpio function types again let's look at this here see value zero for input one for output and we'll one for each of the functions so we'll create one enumeration value call it gf input equals zero gf output equals one we'll say gf
(07:54) um we'll call it the alt zero is going to be the alternate 0 function was the value 4 values in the data sheets were binary numbers so the actual value for that next one will be 4 then 5 and 6. then seven and then it wraps back around to two and three on our three and two so that's going to be our enumeration we'll use in our functions so we'll have a couple of functions here gpio say pin set function it's going to take in a u8 for the pin number and then a gpio func type so that'll be what we set it to
(08:48) we'll go ahead and create another one here gpio pin enable to enable a pin because before you enable a pin you have to actually turn its clock on and set it set how it should work so we'll just take those and we'll create a c file here gpio.c include our gpo.h header and let's create an empty functions for these for right now okay let's go back to here remember we had 10 of these for each of these function select registers so 10 for that first 20 30 40 50.
(09:49) so yeah what we what we want to kind of do is see how we can pull out three bits for each one so we can use a little math here to make this function easier to figure out which pin to select so we'll say the bit start equals pin number times 30 or sorry times three mod 30. it'll give us where the bit starts in the register and the actual register is just going to be the pin number divided by 10.
(10:28) so now we can create a little selector here so this is our u32 red value we're going to grab the function select at the reg value now we need to do some bit manipulation i'm going to assume that you understand how bit manipulation works if not let me know in the comments and i can go more in depth on it but essentially we're gonna clear out three bits for that bit section shift it over and then or in the value that we want to turn on just those bits in that specific register now we need to go back and write to the
(11:13) register same register now we're going to give that new selector low value and that will be our pin set function so for pin enable let's go back again to the data sheet this is useful to understand how to read data sheets you'll see we have the section here for the pull up pull down enable and the clock zero and one we can go over here to the details for those registers see here we have the clock registers now notice there's this section right under here it says how this clock register works so in order to actually enable the cross
(11:55) register there's a few steps to follow right to the pupd wait 150 cycles right to the clock that you want to modify wait 150 cycles right again to the pull up pull down register and then right again to remove that clock signal it's just a step that you have to go through that will help the uh microcontroller know what you want to do with that gpo gpio pin so let's start by our pull-up pull-down enable we want to write zero to it and we want to delay the 150 cycles include r utils.
(12:46) h so we have delay now we want to write to that specific clock remember there's only two clocks so we really just need to take our pin number divided by 32 this is one bit for each pin and we just set the value to one shift shifted over by the pin number mod 32 now delay 150 not seconds 150 ticks and then we again write to the pupd enable and then finally write to the clock again same pin number and just zero to reset it so that will enable our gpio pin so that we can start using it remember these are the steps here in the datasheet
(13:46) okay so now we're done with the gpio related code here so this is a good stopping point and in our next video we're going to start with the actual mini uart implementation which will actually use these auxiliary and gpio structures that we created and and utility functions so again thanks for watching if you like this video like comment subscribe and i'll see in the next video
