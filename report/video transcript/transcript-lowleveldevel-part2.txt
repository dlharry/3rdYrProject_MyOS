Raspberry Pi Bare Metal Tutorial - Part 2 - YouTube
https://www.youtube.com/watch?v=r3Ye08ktcMo

Transcript:
(00:00) hi and welcome back in the previous video we set up the initial project and showed where to find the base peripheral addresses for the pi 3 and 4. now let's start on with the rest of the headers i'm going to start with the common.h file this is just a header file that i like to include which has all the standard type defs that i'm going to use throughout the project i'll create one for each of the base types you went 8 you went 16 and you went 32.
(00:35) i like to have these just shorter form to use throughout the project it's a little easier to type i'm also going to create a type def for a volatile u32 to use for registers and if you don't know what the volatile keyword is for it's primarily to tell the compiler to leave your code alone i know what i'm doing i'm writing a reading to this for a reason no so let's go on to the mini uart file i'm just going to define some of these init methods read and write addresses that were read and write functions that we're
(01:11) going to use throughout the program so we initialize we receive a character we send a character and then we can send a full string these are just going to be the initial definitions which we'll fill out later and a memory management header file again pragma once the top so here we're going to define several of the variables that that deal with memory management and actually if you look at the linux source code you'll find these in their core memory management this code is actually taken straight from the
(01:54) linux source code so initially we're defining the size of pages and page tables but and all of this is done up front so we can initially set off where our low memory is going to be which is what we're eventually going to set our stack pointer to and if you follow sergey's tutorial i believe he goes a little more in depth on these as well and this section here we're gonna we need to include this in our in our assembly files as well but the assembler will break if we add function definitions in it
(02:45) in a c style so we can include this section here so that we can include these defines in both our assembler and our c files now let's move on to the utils these are some simple utility functions and a couple of them i don't know that we're actually going to use but i'll just create them here so we have the delay which we're going to need to delay the number of ticks and then i put 32 which will put a 32-bit value at an address and we'll need to get 32 as well which is going to return an unsigned int
(03:34) from an address and actually you know what let's go back and make a u64 as we because we're going to be using 64-bit os here so we'll create a typed it for uint64t and we'll just use that one in place of those unsigned longs so we want to be sure that we're using the right size for addresses here so we'll just swap these out let's add a description form so we have delay and ticks put 32 address u32 value and this returns a u32 now let's get into some of the assembly
(04:42) code for these utils i'm going to create some assembly functions here these come straight from sergey's tutorial as well for the delay function we're just going to subtract one from the value passed in which is in the x zero register and then branch back to delay until the value is zero essentially okay another function here for put 32 so we're going to store register w1 the address x0 and load register w0 from the address x0 what am i forgetting here oh yes create the label for it now let's move on to the memory
(05:48) management we'll create a simple mem zero function here and again i'm going to assume you have some familiarity with assembly language so i'm not going to go in depth in detail how all this code works but essentially we're just using the zero register in a loop to store a null in this address and once we're done we just return now let's go into what the kernel's main c code is going to look like right now we're just going to start with a simple hello style kernel let's include our
(06:36) headers that we need here so our main is actually going to be called kernel main which we'll call from our boots our buddha assembly file at the top we're going to just initialize uart and we'll send a string simple better than a hello world raspberry pi bare metal os initializing followed by slash n and let's have a section here so if you're if you build this for the our pi version 3 we'll mention the board name here and the output string as well and likewise we'll do the same for the
(07:37) four here okay then we'll just put a done string here put a couple lines and then say we're done and let's go in a little uh infinite loop here to just read and send echo back the input that the user types okay you know what let's go to the extensions i want to add our clued path here so i'm going to go to the c plus plus extension let's see look for include pass edit the settings.
(08:28) json i'm just going to add an entry for just include so that way it picks up our include directory in the file so now you can see there's no errors here that's just a visual studio code thing so let's dive into the boot code here first we're going to include our mm.h so we have those headers we're going to specify this section as the dot text dot boot section so this will be at the very beginning of the file create our global start function so first we're going to use the mrs instruction here we're going to pull the
(09:13) um cpu id out into x0 and we're going to end it with ff so that we can verify if this is we're going to branch here if the value is zero for the comparison we'll branch to our master section which is going to be the which is going to be where our main kernel code is if not we're going to branch to proc hang which is just going to hang the processor so our master section here we're going to start by getting the ba bss begin address and the bss and address let's get the size of that by subtracting
(10:05) and then we're just going to run mem 0 on that section so now we're going to set the stack pointer to that low memory variable we created and then branch off to kernel main and then branch to process hang which it generally won't get here because it's an infinite loop and proc croc hang is just going to simply do a wait for event instruction and then loop back to proc hang so now we're off to a good start here let's get on back into the header files here so i'm going to create a couple more
(10:58) headers here one for auxiliary registers aux.h and let's create another one here see we had uh i believe mini you are mu art no it's a mini uart.h let me rename this let's see we're going to add a gpio.h because that's required for the uart and actually you know we're going to do this uart code differently than sergey does so i don't need this mini uart dot h in the headers because i'm going to make use of the aux and the gpio for that so starting with the aux here let's take a look at the data sheet
(11:57) if you see the mini uart section in 2.2 it's a part of the aux the auxiliaries so let's go down to here and you'll see in here we have the registers that handle the mini uart the first couple auxiliary registers there and then here these are all the mini uart related registers everything from io error handling and you see this starts at 21 5000 and 5004 then there's a big gap right before the mu art and then all these go right one after the other so they're they're each you know eight well they're they're each uh 32-bit
(12:48) registers and we can go down here we see you enable mini uart with that very first register and there's you set bit zero as defined here to enable the mini uart which you see this was a register right here that we call so what we'll do is actually create a structure for those so let's go back to the aux that h add our pragma once include our common header and let's include the base two because we're gonna need the base address so we're gonna create a structure here aux regs it's going to be our main structure that
(13:38) holds all those registers so if you remember first we had an irq status actually rank 32 irq status then we had the enables and then if you remember there was a big gap here 5004 to 50 40. so we need to put something in place of there we'll just call that a reserved section so we'll say reserved and that's 32 bits times four fourteen so now we go on with the uh mini uart registers there was first the i o register then the i air register followed by iir the lcr we had the mcr
(14:51) the lsr see the msr now we have the scratch control register in the status register and our baud rate so those are all the specific mini uart ones that map directly to these registers which come one after another in the memory map scratch control register status register baud rate and then all the rest of these are related to the spy controller which we're not going to use right now so now to access this we see that the offset here is 7e 21 5000. remember 7e we need to translate
(15:58) that to 3f which is our p base our peripheral base so 21 5000 is really the number that we need to use to access this so what i'm going to actually do here is create a define and i'm going to essentially create a pointer to that location in memory which gets cast as a pointer to the struct so we use p base plus that 21 5 000.
(16:33) so whenever we use this reg aux we'll actually be able to access these fields from it so i think that's actually a good stopping point here in the next video we'll go over the gpio section so uh what we have two register sets one for the aux and one for the gpio and that's how we're gonna essentially control those pins for the mini uart to communicate to the raspberry pi with via our terminal and as always if you like this video like and subscribe comment and thanks again for watching
