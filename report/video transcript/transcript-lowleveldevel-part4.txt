Raspberry Pi Bare Metal Tutorial - Part 4 - YouTube
https://www.youtube.com/watch?v=58f8Qfh-T6Q

Transcript:
(00:01) hi and welcome back in our previous video let's see we went over the gpio related code in this video we're going to finish up the code by starting off with the mini uart and then moving on to the linker so let's get started first we're going to include the gpio header that we created see we'll add the utils i'm not sure if we'll need it but we might as well add it anyway so now i'm going to create a define here for the pins that we're going to be using for the the txd and the rxd
(00:47) which is the the read and transmit and receive for the mini uart and those pins are 14 and 15. so in our uart init function the first thing we're going to need to do is actually set up the functions for those uh pins to be alt 5 so we'll use txd gf alt 5 and we'll do the same for rxd gi fault 5 and now we need to enable those pins so we'll use that function we created last time for txd and the same for rxd so now let's go back over here to the datasheet you remember we have the aux enables register here if we go down and
(01:40) look at the register details right here we'll see mini uart enable is the very first bit in that register so we need to set that bit doing so we can use our regs aux um which yeah we need to include the peripherals for that peripheral slash aux.h okay so now we just set enables to one that'll set the first bit to one now there's a couple other of uh registers that we need to set up to get the uh mini uart running here first we set control to zero so we can set some of these extra flags including the i air will set to zero
(02:31) the lcr will set to 3 that sets it into 8 bit mode so then we have the mcr we set to zero let's see and now for um let's see for different versions of raspberry pi we're gonna have to set the baud rate differently here so for raspberry pi 3 has a 250 megahertz clock that's the system clock so we'll say mu baud rate equals 270 and now if we go into the data sheet here you'll see where we do the calculation for this right down here in this section there we go mini you are so uh see the baud rate
(03:22) is equal to the system clock frequency divided by eight times the baud rate register value plus one the baud rate resistor value is what we put in there as 270. so that's going to mean that we're using 11 5200 as the baud rate at 250 megahertz so now the raspberry pi 4 has a 500 megahertz system clock so we just need to adjust that value and 541 is the correct value to use for that at 500 megahertz and so now when we're done here with these values we set the control to three and that should be everything enabled so let's just send
(04:20) some returns here because we need a lot of debug output from uh the raspberry pi bootloader that we included in our config so i just want to put a separator there so we can see our codes different and we want to include the mini uart up there so let's start here by creating the first function you are send we're going to send a character so now in order to send a character let's look at the data sheet here there's a specific register lsr yeah lsr register there's bit five here in the register is how you determine if the fifo can
(05:11) accept at least one byte that means it's ready to start getting data so that that we can send so what we need to do is just loop until that bit is unset i'm sorry until that bit is set so that bit we'll we can use we can end that with 0x20 that'll give us that fifth bit and we can just put a semicolon here because we're just going to loop while loop forever until that um until that flag is set so we can actually send data and then we send data with the i o register so we just set the value in the i o register and
(05:51) the uh the hardware will take it from there so now we'll do the uart receive which we actually return a char and we basically are going to do the exact same thing but on this one you'll see that um bit zero is the one so this bit is set if the received fifa holds at least one value to read so it's gonna we're basically gonna do this same loop while bit one isn't set that means nothing's available to read yet so and then we'll just gonna read that same register but you know this is a 32-bit
(06:34) register so we want to end it with 0x ff so we just get one byte you see that's a reg 32 we just want one byte one char out of it then we'll add a convenience function here just so we can send a full string at a time instead of one char at a time so what we're going to do is just while you know the dereference value is not the null terminator we'll do a uart send just that dereference that current value and then stir plus plus now also about up here we want to add a check so if that value is slash n
(07:18) that's only going to do return it's not going to do the it's it's only going to do a line feed it's not going to do returns we're going to add a slash r in there automatically whenever you do slash n so you don't have to type slash r slash n all the time so now the only thing left here is the linker so we'll start with the sections and right at the top the first section is going to be our dot text dot boot so now this is going to put that right at the top of the binary file and if you remember this dot text dot
(07:58) boot is straight from our boot file where we define that this is the section.txt.boot so the link is going to put that code right here at the top then after that we'll just copy this and we have the dot text section the read-only data section ro data and then the normal data section just dot data and then after here we we have the bss section which we actually want to align that on a as a eight bit value so it'll be aligned on eight bits and let's see let me add a add the link or script and here you go now we have a little
(09:00) nicer looking code with the plugin so uh yeah if you remember right here we have our bss begin and our bss end where we're subtracting the value and then zeroing the whole section that's basically what we're doing this section here for and this is the static data if you can look up bss it's a it's a place where static uninitialized variables are put and we just want to mem zero that whole section as a part of our boot process and and there's some more details you can get if you look up the
(09:42) linker script details on the internet there's plenty of information about how those work so now let's go ahead and make clean and just run a make and it looks like everything succeeded except for the process of copying to the boot media so that'll bring us to our next section actually where we'll cover downloading the raspberry pi os and creating a bootable drive out of it so that we can copy our kernel to that boot drive so again thanks for watching if you enjoyed this video like comment subscribe and i'll see you
(10:24) in the next video
