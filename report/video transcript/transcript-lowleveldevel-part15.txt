Raspberry Pi Bare Metal Tutorial - Part 15 (Video with DMA) - YouTube
https://www.youtube.com/watch?v=4JtZQ88x5_c

Transcript:
(00:01) hi and welcome back to the low level devil channel's raspberry pi bare metal series in the previous video we showed how to do video output in this video we'll show how to speed up rendering by using dma i'm only going to implement enough of the dma for our needs in this video output optimization to to keep things simpler there's there's actually a lot more to dma and i also make reference to another project called circle on github which has a a good uh implementation of a bear uh bare metal raspberry pi library
(00:38) it's pretty complex it's all written in c plus plus but um i i reference that because i used some of their ideas on this video um also if you have any questions related to this video don't forget to check out the discord server and subreddit both are linked in the description so let's get started i'm going to start by showing where some of this information is coming from it's section 4 of this broadcom peripherals details and there's a lot of good information here so i'd suggest you read through it
(01:11) if you want to know more for instance it talks about the control blocks which are very important in dma and we'll implement those and let's see some other information here talks about the fifo and overflow and underflow a lot of details you need to know when implementing and uh this dma controller has 15 different channels and each has an identical register map so channel 0 is located at this address channel 1 is the same address plus 0x 100 and then channel 2 200 and so on so they're they're each separated by the
(01:53) same uh and channel 15 is actually completely separate but i don't we don't need to worry about that for this use um so you'll see that this offset 0 100 200 300 400 and so on all the way down to register 14 is like that so continuing on here we have our control block structure so uh let's see these are the different just talks about the different registers that you'll be able to use this control block structure is the important one that we're actually going to use and as you can see it's got
(02:33) this several different uh u32 values transfer information source and desk address transfer length it's 2d mode stride and next control block address and let's see what else do we have in here yeah so yeah again reading through this stuff will help you understand the process more and what's really going on now we have the actual definition of the registers so for each of the registers they start with the control and status register like many uh peripherals then a control block address and then this next section here
(03:16) you'll notice it's actually the same values as up here in a control block so we can actually reuse our control box structure that we'll create as a part of our registers as well there's also this debug flag where we're not going to use it but as you can see this next one starts at 0x100 offset and that continues all the way down at the bottom there's actually two extra registers at the very end so you have e20 and then fe0 is the interrupt status register and ff0 is the enable register to enable
(03:55) the different channels and then after that we have the definition of the control root status register all the different bits which i've showed you how to read this in a previous video so i'm not going to go too much over it but for instance you have bit 31 as the reset bit 30 is the abort so yeah from the previous videos i think you should understand how to get through and and actually understand what all these different flags mean okay and i think that's all we need to do on the data sheet so let's go ahead and
(04:33) start just creating some of the files so to start with we'll create a dma.h and peripherals which has some more of the uh internal information and we'll start with uh let's say the structure for the control block because that's going to need to be used adding in some headers here so let's see so the control block has if you remember transfer info that was the first uh field in it do we have the source address the destination address okay we have the transfer length mode 2d stride then this uh next block address followed
(05:26) by some a couple of reserved uh fields which we're supposed to set to zero i don't know how important that is but i'm gonna do it anyway so that's our dma control block so now that we set that up we can set up the actual registers if you remember there was a control status register and then the control block address followed by essentially a dma control block okay and i'll call that dma channel regs all right so now i'm going to add a define if you remember on all the other peripherals i create one to grab the
(06:16) registers this one is going to go by channel so i'm going to pass in the channel as an argument and let's see i'll use the p base plus that 0x700 7000 and then plus actually yeah i don't want that outside there so plus the channel times 0x100 all right i think that's it so then i'll add a couple of other defines for those other two uh the interrupt status and that enable register because we need to be able to use at the very least the enable register and so now that we're done with that let's let's create some uh
(07:05) defines for some of those different bits and i'm actually just going to paste those in you know as it's going to be the same as the other videos essentially i define them based on shifting bits over like if you remember 31 was the reset and 30 was the abort so uh and now we'll create a another dma.
(07:37) h in our regular include directory so we include our peripherals dma and let's see we're going to create a structure for a dma channel and the things we need to work with in there is the channel that's going to be the number of the channels of channel 0 1 2. then the control block and then a status of it whether it was successful or failed and we'll create an enumeration called dma channel type and we're essentially going to be working with normal channel types but uh we have the none which is for error conditions all right i'll just set that to 0x81
(08:31) so all right and now we have a couple of functions that we need to implement here the dma open channel which is going to pass in a channel value and get back an object or a structure i guess you'd call it so we're going to need to be able to close the channel as well just cheat here copy and paste this so we'll have a dma setup mem copy so this is going to set up the memory that we want to copy from the source to the destination length and then this burst length okay and close channel we change this one to
(09:23) a dma start so this is when we're going to actually start the transfer and then dma wait to actually wait for the transfer to finish you don't always have to do it in a blocking style but for our purposes that's what i'm going to do here and i'm adding a couple defines to our mem copy as well because i'm doing a little bit of cheating since we don't have a memory allocator i'm gonna directly address some things and also i'm adding this bus address in here which we use uh the gpu members
(10:04) either cached or uncached let's see i'm done with that now we can go and start the implementation so i'm going to add a dma.c file include a couple of things here if we want the dma header we need to include mem.h and mm.h because we're going to be hacking the memory here's without an allocator timer and the printf okay so let's start with creating a dma channel array so this is going to hold all the 15 channels and let's see we'll next go to a channel map and actually kind of stole
(11:01) this idea from that circle project that i mentioned at the start i mean let me just bring it up so you can see it so i am getting some of my ideas for this video from that let's see circle so it's a good project i'd suggest looking at it if you're really really into bare metal raspberry pi stuff if you haven't seen it already most of you probably have but um it's as you can see it's all c plus plus code um let's see i can look at the dma channel here it's pretty complex you know there's a
(11:44) lot of code to this and our code is going to be a lot simpler because we're just using it for video rights for now and transferring between two memory locations so now let's continue on we're going to create an allocate channel function it's not actually allocating memory it's just giving us the a channel that's available essentially and i'm just gonna paste in the code that i did for this one but what it's essentially doing is looking in the channel map well first of all it checks to see if uh if there's
(12:22) any bits past us first 15 because if so then that would mean that they passed in or or if there's not any bits that would mean they passed in the not ct normal as the channel but an individual one so we're going to check the map to see if a bit is set for that specific channel if so it's going to unset it and return the channel because you can pass in the channel number or you can pass in ct normal if you pass in channel type normal it's gonna loop through all the normal channels there's different types of
(12:58) channels but for for our case normal channel would be starting at six down to zero so it's going to loop through each one find one that has the bit set and then unset that bit and return it so it's essentially going to reserve that channel for our use okay so now i'm going to create the dma open channel which is going to use that function so we'll start by creating a dma pointer to my channel i'm gonna actually i think before that i want to grab allocate the channel because i want to grab it from my uh
(13:46) channels array up there so let me say int channel or actually u32 channel equals allocate channel journal and then pass in the address of channel number channel and something let's yeah i got duplicate variable names here i'm just going to add an underscore at the beginning you could call it something else underscores i believe supposed to be reserved in c so might not be the best name for it but okay with something still complaining here channel this should be channels yeah all right so i'm gonna grab that dma channel structure
(14:49) set its channel to channel okay so now if the dma channel is let me do this first actually because if it returns ct none we want to exit because that's an error we don't want to try to grab channels negative one so if channel equals ct none print down narrow invalid channel and then the channel that was passed in and we'll return a null pointer all right so now the rest of the setting up is going to be pretty simple we need to create this block now a little bit of a hack here we're taking our low memory
(15:47) um and this plus 32 and tilde 30 plus 31 and tilde tilde 31 it's just a way to align that pointer but uh this low memory is actually the starting location of ram essentially i mean it's not just that but that's where we would normally start allocating memory so for now since we don't have allocate function i'm just going to set this pointer to that to that once we have an allocator maybe in the next video we'll start on it then we'll kind of redo some of this now i'm setting those reserved values to
(16:30) zero so now that we've allocated now what i want to do is set this regs dma enable register if you remember we created a uh a define for that macro one shifted over by dma channel so that's going to enable this dma channel yeah there you go now we're gonna sleep for three seconds to give that our three milliseconds sorry to give that time to uh set up now we're gonna grab the dma registers for this channel and we're gonna order on the control register cs reset so now that we've set that reset bit
(17:26) something here is not working right okay yeah let me just go to that macro it looks like i probably missed a part of these okay let's go here to the end yep yeah i missed a close parenthesis all right so now that we've set that reset uh flag what we want to do is loop while that reset flag is set because during the reset process that flag is going to be set so if it has the reset flag still set then we're just going to continually loop and putting a semicolon there is what causes it just continually loop
(18:29) and now we can run dm return dma so now we've opened our dma channel next thing is going to be to close it so to close it really all that we're going to do in this case is just remember the channel map we had we're just going to reset that bit so let's see so set that bit again one over by channel that's all we're gonna really do for the close channel so now we need to set up our memory transfer and remember that takes a dma channel structure the destination and source the length and this burst length
(19:34) okay so all right i'm just pasting this in so what we're essentially doing on the channel block transfer info we're setting this burst length value by shifting that over by the by 12 and oring these other flags onto it all that information is again in the datasheet then we're setting our source address destination address transfer length our mode 2d stride and next blocks to zero and that essentially is all that's needed to set up the transfer and now we implement the start transfer so let's see again we grab
(20:32) this channels registers so in order to start it first we need to set the address of this control block so we need to use this bus address macro and we're going to pass in channel block so that's the memory that we had allocated for this block now channel channel now on the control register we want to set that to active along with a couple other things i'm just going to paste those in here again this is all in the data sheet setting its priority its panic priority its default regular priority and its active flag
(21:37) so that will kick off the uh the actual transfer now we want to wait for it to finish and this is going to be similar to what we do when we're initially allocating the channel and resetting it now we want to loop while the active flag is set on it so we're just essentially waiting it for it to not be active anymore then we'll set its status by grabbing the channel registers error flag which would be in the control status register so if cs error is set then we know it failed and then we could just return that
(22:34) status in this function and that's all that we need to implement our dma transferring and we need to go back to this dma header and change this to bool because the weight just returns that status and now we can take a look at our video dot c i've made some changes from the previous video to start with we have our dma channel variable here a couple of uh buffers we have the video buffer which we're going to be using for dma two background buffers one for 32 bit and one for eight bit so we're going to kind of copy the
(23:23) background into there at the start up so we can see how fast it transfers just the background so you can alright so now we have our megabyte defined just and again we're doing this little bit of a memory hack here just put a comment so hack for not having an allocate function yet so we're going to set the background 32 buffer location i'm going to set it to low memory plus 10 megabytes now we give it 10 megabytes for that block which it won't be that big but and now for our bg eight men location and our video buffer location
(24:13) again this is all just a hack we'll come back and revisit these with actual allocations once we implement a memory manager alright so now in our video in it this is a new function we're creating our dma channel opening a dma channel allocating our buffer by pointing it to that address printing out some details doing the same allocating these two buffers and then i'm going to actually fill the two buffers so the bg 32 buffer one i'm going to fill with this back color essentially i'm looping through the
(24:57) whole thing and filling it and the same with this bg8 buffer in this one i'm setting each value to zero one and that's going to be the pallet index which will have to implement pallets down there so we have a flag for using dma our bus address i think i already had one of those in another header so i don't know that i need this one here but so then we have our frame buffer let's see in our dma buffer which is the vid buffer and if we use dma we return the dma buffer or the frame buffer for drawbuffer
(25:45) we have a little uh function to set dma on and off and then our actual do dma i have some timing here so i can just print out how long it actually takes to do the dma so now this start okay so we have our total number of bytes so essentially we're going to loop while we're sending this starting from the destination start and and source start sending the number of bytes maximizing it to ffff call our dma start our dma weight for each section and then we increment our start and decrement our total by the number of bytes
(26:44) hopefully you can follow that all right and then we have a separate function for video dma which in which we pass the frame buffer the dma buffer and the screen size so now we have a a mailbox palette so when we do 8-bit graphics we need to set what the palette is for those graphics so we start with an offset because you have multiple ballots the number of entries and here we have just an array of eight for the eight entries video set resolution we did before i have some changes to it this mailbox set palette which is using this frame buffer set
(27:28) palette tag size is 40. i'm going to do offset zero so palette zero eight entries we're starting with zero which would be black then we have that background color followed by all white see then we have like a blue a green and a red and a couple shades of gray and we send the initial request like we always did and a special request if the bit per pixel is eight we set the palette okay so now let's see we don't need this printf let me get rid of that so now we're going to loop four times and we're gonna
(28:25) uh count the timing for each of these four times okay so we have our start so if it's 32 bits per pixel and we're not using dma let me get rid of these comments i was using mem copy but that was too slow so we're taking our frame buffer and copying each byte from the background into the frame buffer okay otherwise we use dma we give it the bus address of the video buffer and the background buffer and the screen size and then likewise the same for eight except yeah let's see we use the bg8 instead of the
(29:22) bg32 buffer okay and now we do some timings here just so i can show the differences in how long things take and then if we're using dma we call video dma and let's see so after that we're going to actually uh draw some of these uh strings so i'm gonna draw a resolution i'm gonna draw the uh back how long it took to draw the background to or two right to the background buffer that would be this section there how long the dma took if we use dma to just this video drawing done string and you can see each of these are at the
(30:20) y 20 40 60 80 plus i times 20. so it's going to essentially go down the screen a tick every single time and we're looping four times for each of these so now we do the video dma to display those strings because those strings are just writing to our video buffer and then we have the the timing that it took to draw all four of these strings plus the dma and all that is going to be the frame time and we're putting that down at the bottom and then finally another dma in case uh so we can see that frame draw time
(31:08) okay then these are all pretty much the same the draw pixels drop character with some extra support for 8-bit okay yeah so we have the different text indexes we're going to use if that's 8-bit color now let's go on to the where we at kernel.c actually up at the top one thing i forgot is video in it we need to initialize that now to start with we're setting dma to false and then we're going to display the resolution 1900 by 1200 then 1024 768 and then 800 by 600 and these all are going to be in 32-bit
(32:00) color then we're going to do essentially the same thing except these are all in 8-bit color and now i'm turning on dma and do the exact same thing 32-bit color and 8-bit color this is to kind of show you the difference that it's going to make when you actually uh use these different buffers because they're very very different buffer sizes i'm going to use my phone camera here so you can see this hdmi output we're booting it up now and this is the first one hopefully you can see that resolution
(32:44) is 1900 by 1200 and you can see it's taking about 2.2 seconds just to draw the frame so this is without dma and 32 bit uh color now 10 24 is 7 68 it's taken a little under a second to draw the whole frame and now 800 by 600 it's taken about half a second to draw the frame now let's do the same with 8-bit color that's about a little over half a second to draw the whole frame that's a lot better for 1900 by 1200 and then the next resolution 200 milliseconds to draw the frame so you could draw this a couple of times
(33:36) a second and then 800 by 600 167 milliseconds roughly now it moves on to dma you can see right away 32 bit color it's taking only 200 milliseconds to draw the whole frame 98 milliseconds to draw it in 10 24 by 768 so you draw this 10 times a second and 800 by 600 at 32 81 milliseconds most of that time is actually drawing the text so now going to 8-bit color you see we're at 85 milliseconds this 165 milliseconds so drawing the pixels is roughly the same timing on both of them so that's why you don't see too much of
(34:30) a difference here eventually we could make some more further optimizations to to the actual character drawing to make that faster as well but for the purpose of this video i think that's about enough i just wanted to show you know how using dma can actually speed things up quite a bit you'll see how long it took to write this last one was three milliseconds to use dma to write that buffer uh the background into the video buffer and then two milliseconds to use dma to write that uh video buffer into the actual uh
(35:10) frame buffer which is pretty fast a lot faster than it was without dma at least so again i hope you enjoyed this video learned something from it you have questions or comments again like like comment subscribe on the video um also join our discord server reddit subreddit and if you did enjoy the video please like it and subscribe for more videos like this and uh share it if you can the more people that know about it the more visits and stuff that i get the more likely i am to create videos on certain subjects so i really appreciate every every uh
(35:54) all the support and thanks everyone for watching
