Raspberry Pi Bare Metal Tutorial - Part 16 (Enabling MMU) - YouTube
https://www.youtube.com/watch?v=X_01ytMQzDw

Transcript:
(00:01) hi and welcome back to the low level devil channels raspberry pi bare metal series in a previous video we covered how to use dma with video output i know it's been a while since i've done any videos in this series i've kind of been stuck on where to go i do plan to eventually add some support for disk access which kind of led me down a road where i ran into issues with unaligned data structures which uh through some research i found that arm doesn't support without the mmu being enabled so uh in this video i'm gonna cover
(00:36) enabling the mmu so let's get started i'm gonna start by showing you a simple example of this align issue so let's start by having a data structure called align check one so let's see this uh align check has several different variables we have a u8 a b and c so that's three u8 and then a u32 d so you would now let's say you have a buffer that you want to read and load into this structure so i'll just create a little buffer here we'll have it 0x 10 20 30 40 50 60 and 70.
(01:30) so if we loaded this into this data structure the value a would be filled with 10 b with 20 c with 30 and d should be 40 50 60 70 but in reverse order of course so what happens if we actually try to do this so let's let's uh just print out some data here align check so i'm going to create an instance of this check ac1 so now i'm going to just mem copy that data structure now it's 7 bytes so now i'm going to print f each of the values from there so we'll have a b c and d we'll just print out the hex values of those
(02:33) so again a should be 10 and then 20 30 and then d should be 70 60 50 40. so let's see what happens when we do that i'm gonna put a sleep timer here just so we can have some time to actually see this output so now i'm going to make now i'm going to look at the output when i start it up so let's give it a second here and there we go align check you see a b c look correct but d is 70 60 50 but it's missing the 40.
(03:13) so why would it not have copied that 40 so well that's because there's actually a missing item in here in order to properly align the data structure by uh um you know 32-bit sections it actually pads the data structure with a kind of a hidden variable in there and we really don't want it to do that because sometimes we want data structures that are you know that are going to be fully loaded from from a memory location so let's show you how to actually get around this padding issue so we can do so by packing the structure
(03:57) so i'm putting packed here on the end and i'll add the definition here in the comma dot h but essentially we're setting the attribute packed on this data structure so if we do that let's see what happens so let me copy this we go down here and say this one's unpacked and this one is packed so let me just change a few things here ac2 check two ac2 okay let's make that and um actually there's one other thing i missed too we need to set this to ac2 ac2 yeah yeah so for each of these we want to make sure reading from the right data
(04:59) structure so yeah let's go ahead and make this again and now let's start it back up and now we can see bam it's got an error so the problem is that's with data being unaligned packed and unaligned like that the arm processor just doesn't support that without the mmu enabled so in order to support that let's work on uh enabling the mmu now if you follow sergey's tutorial which i you have mentioned in previous videos he has this lesson six where he covers pretty well in detail how virtual memory management
(05:45) works um the translation process it's got a nice diagram on how the different pgd pud pmd tables are all set up and he he puts everything in this tbr zero register and the tbr one ttbr1 registers i'm gonna do it a little bit different than the way he's done it because his is focused more on having separate kernel and user memory but for me it's bare metal and my project so far isn't really focused on having a user environment it's more everything running in the kernel also his only really supports raspberry
(06:26) pi 3 doesn't support for the way he does it but um actually there's another good repository by someone named rhythm16 and he's on the discord channel and he's helped me kind of get this working for the raspberry pi 4 and uh let's see if he look this is the person here rhythm 16 looks like he's from taiwan and he's got this project here our pi 4 bare metal it's very much based on uh sergey's tutorial so his is also focused on having a user level and kernel level memory and a lot more complicated i'm
(07:03) going to do a much kind of simpler approach rather than being able to switch between user and kernel mode and having uh two different registers to manage all the memory so i'm going to use something called identity mapping or just it's a one-to-one mapping so first i'm going to add in the make file we're just going to have a flag so we can enable and disable this call it mmu so let's see dash d in mmu equals that value so now in the kernel i'll just put some information here showing that it's
(07:46) initialize the mmu if it's set to one so that we know when it starts up if it's enabled initialized mmu of course that's not all there is to it but so uh let's take this and go into our boot.s so in boot.s first under this master section let me just add this in here and we have some extra registers that we need to set so in the case of initializing the mmu before we get into el1 we need to first we're gonna load this c p a c r e l one value into x zero and we're gonna write that into the cpacr el1
(08:44) register now another value we need to load in is the tcr el1 register value load that into the register and then the mair register and actually sergey covers that in pretty much well detail what that register is and the purpose for it and all that so i'd suggest reading that if you want to know more about some of these things so i need to also include this mmu.
(09:30) h and i'm going to just add it up here let's create a new mmu.h this has several values i'm just going to copy over that's straight from uh sergey's tutorial so first we'll start with the pragma once at the top and i'm just going to paste all this in and it'll be in github so uh you'll be able to just see it from there okay so that should have all those values needed so let's go back to boot.
(10:06) s so now down in the el1 entry section first i'm going to take this stack pointer and move it up and so what we want to do after we do that mem 0 of the bss begin let me again copy this over so we only want to do this in case we are initializing the mmu so we're just going to call this uh we'll call it init mmu that's the name of the function where we're going to put all this initialization in now in sergey and rhythm 16 they both do this all in assembly i'm gonna um kind of do it in c so it's a little easier to read for me
(10:55) so next we need to load the address of the id pgd table and this is something we're actually adding to our linker so that's the linker.ld file so down here at the end first i'm adding an align section so now this is the section where we're going to store this identity table and let's say dot data dot id pgd so this is where the data for it's going to go and the size of it is going to be 6 times 1 shifted over by 12 and that's you'll see later it's related to the the number of uh sections that we have
(11:46) in here so let's close that out so so we need to load that address because that's where we're going to be writing all this data so we're loading the address into x0 so that we can use msr to write that into ttbr0 so this is um it's the register that will control the page translation when the mmu looks up uh memory addresses so now let's grab the sctl el1 value i'm going to put it into x0 and then we're going to into x1 we're going to put the sctlr mmu enable flag and now i'm gonna order those together
(12:46) and write it back to the sctlrel1 register so that will essentially enable the mmu so before we do that we have to actually uh so then it'll you know jump down to the kernel and before we do that we need to actually implement this init mmu function it's going to be pretty complicated there's a lot of good details in sergey's tutorial on what all these different things mean but for now i'm just going to kind of judge through it with you so let's start off by adding a few headers to this we'll add the uh
(13:25) let's see the peripherals base we want that the mm.h and our mmu.h uh probably should add printf in case we want to print out any stuff this is actually before the printing is uh available but we might use it later so what now let's uh start by i'm gonna paste in a bunch of defines and most of these come from uh from sergey's tutorial and from rhythm 16 has made some updates so that they'll work on raspberry pi 4 so i'm not going to go into them all in detail but you'll see this id map pages 6
(14:13) and the table size is six times page size which uses that shift that's where that value comes in from the ld file okay so we'll start by creating a table so you have a function to create a table entry and it's going to start with the table location and then we're going to have the next table location the virtual address a value for shifting in and the flags so to start with we're going to get our table index by taking the virtual address shifting it over by that shift value and we need to end it
(15:03) with let's see entries per table minus one that'll get rid of all the other stuff that we don't need for the index value so now we will get the descriptor in the descriptor we get from the next table board with the flags okay now we need to write all this data to let's take cast the table plus the table index shifted over to the left by three that's the location we're going to write the descriptor so hopefully that makes sense putting the descriptor in the value of the location in memory here that table plus the table index
(15:57) so now we need a function to create a block mapping and that's gonna use the pmd table location it's going to take in the virtual address start the virtual address end and then the physical address we're mapping to so let's start by restart we need to shift it to the right by section shift and now we need to end it with entries per table minus one and now the v end we need to essentially do the same with that but we need to subtract one from it after shifting and the same thing here so now we're going to
(17:02) take our physical address shifted over to the right spice section shift and then shift it back that gets rid of some of the low bits and now we'll go into a do while loop so essentially for each of these addresses that we want to map first i'm going to take the physical address now if the physical address is greater than or equal to the device start location we want to use different flags device start i haven't defined yet let's see so we'll put that in the base dot h so for r pi it's going to be 3b4000
(17:46) and for our pi for fc followed by six zeros so that's going to be where we need to change properties um i need yeah let me add a default value just to appease my ide here or editor it's not really an ide there we go okay so now so if p a is past the device location then we're going to or it with let's see td device block flags so otherwise we're gonna order it with td kernel block flags and now we need to write this value
(18:49) okay similar how we did before we're gonna cast the p m d to feast uh adding with v start shifted over by three and p a we're gonna add section shift or section size and v start plus plus and we're gonna do this all while v star is less than or equal to end and it looks like i spelled something wrong here p this should be pmd so essentially we're looping through each of these uh locations and mapping the virtual to the physical but in our case the virtual and physical are the same address since we're doing
(19:38) an identity mapping so now let's call these functions in our init mmu function so to start off with we actually need to get the address of this id pgd so i'm going to call a function called idpgd adder which we actually need to define and implement so u64 id id pgd adder i'm going to put that function in our boot.
(20:11) s i'll just put it down here at the bottom so uh we'll do global id pgd adder and idpgd adder we'll just use adrp into x0 id pgd and return so that'll give us the location of that block of memory because that's where we need to start writing the data for our mapping tables so first i want to clear that out i'll use memz0 idpgd and the size is going to be the id map table size okay now when it gets our map base is zero because let me start at zero and the table is id pgd and the next table is idpdg
(21:15) pgd plus the uh section size or page size sorry so now let's call create table entry where we pass table next table and then our map base the shift value for this is going to be pgd shift because it's the pgd table and the flags are td kernel table flags so now that we've created our pgd table entry now i need to increment this table and the next table okay so now we'll create another variable here for the block table it's going to equal the table the current table now a for loop we need to do
(22:17) zero to four all right so now we're going to create table entry this is going to be essentially the same as that other one except instead of pgd shift it's going to be pud shift so yeah pud shift instead of pgd shift so we're creating four of those tables and four block mappings for them so next table plus equals page shift map base plus equals the pud entry map size and block table plus equals page size and now we can say create or actually do our offset our offset is the block size times i so block size is
(23:19) this value here so it starts at zero and so now when we do create block map we're mop or mocking we're mapping the block uh at that block table from offset to offset plus block size and then the physical address starting at offset so we're mapping this is our identity we're mapping a virtual to physical as the same value normally you won't do this if you're doing an operating system or something like that there's other ways of doing this or much better but this is the simple approach that i just
(24:12) need to get the the mmu working so let's try to build it and i'm running into some issue i think i missed a couple of things i need to add something to our sys rigs so let's go up to our sis regs and i'm pasting in some values these i took from our rhythm 16 he has a bunch of uh extra fields here and uh i'm not going to go too into detail on them uh he he put some good comments on there as well again check his github page for some more details so let me save that and i think that's all let me make
(24:59) clean and make again and okay there we go so now i'll jump over here and restart it give it a second to boot up and so now we have our unpacked and our packed section so if you notice in our pack section d is correct it's got 70 60 50 40. so it actually packed the structure correctly so all the data is in the right place so you see the a is 10 b is 20 c is 30 d is 70 60 50 and 40.
(25:43) so it all looks good and that's not possible without initializing the mmu so let's go back and i'm going to make clean and set the flag to uh zero so i can say init mmu equals zero make okay let me copy this over again and start it up and sometimes i need to unplug my cord and plug it back in for this startup to work let me do that and i'll start it up and here we go so again this is no mmu and we get the error because there's no mmu so we can say that this works properly when we enable the mmu and without the mmu we get the
(26:46) unalignment error so that's most of what i really wanted to go over in this video but since we're dealing with memory i'm going to go ahead and add some allocation as well it's not really allocation it's more like reserving pages but uh let's start with a simple memory map which has paging pages number of pages and this i'm taking straight from uh sergey's tutorial as well but i'm kind of modifying it some so his is really his is let me let me find the source here is this more for uh fetching a page at a
(27:27) time and then doing something with it let's see it's down here in mm.c i think yeah so you'll see some code copy in here but this is where he's allocating pages and i shouldn't use the word allocate but you know you know what i mean um so he's doing one page at a time but i find that when i need memory i generally need it in larger chunks at the kernel level so i'm going to actually add some values here i'm going to set the high memory location to one gigabyte so everything between low memory and high memory is
(28:04) going to be the data that we're going to be able to allocate with our page page by page allocator so let me save that and go back to mem dot c so now so each value of this table if it's zero that means it's unallocated and if it's one that means or non-zero that means it's allocated so what i'm going to do is get free pages so you give a number of pages that you want and they're going to have to be contiguous of course so let's say a start index is 0 and a count of 0 to start off with
(28:45) so now i'm going to loop through each of the available pages paging pages so if that page at index i is zero that means that it's available so it's not yet allocated so what i'm going to do is say let's see if not count that means i don't have any other pages yet i'm going to set the start index to that current value now i'm going to say count plus plus and if count equals the number of pages that means that i was able to get all pages together so now i'm just going to map start index
(29:30) equals count so i know how many pages have been allocated after this so i'm setting that value to count and now uh for each value after that that i've allocated so for one to count i'm gonna set their value to one because really i just need some value in there and let's see so now to get the pointer i'm going to cast to void pointer low memory plus the start index times the page size so that will give me the location and memory to use for a pointer and i'm just going to add some print details
(30:24) just so i can kind of debug if if problems happen with this and address percent x so count start index and p then i'm just going to return p and now so if the map is not zero that means this one's already allocated so what i need to do is set count to zero because i want these all to be in a row contiguous memory that i can write to all right so let me let's just double check yeah everything looks right so i'm going to take this and put it in our should i put in mm.
(31:12) h no um i think there's a mem.h yeah mem.h i'm going to put it down here and so now let's add a helper function because we don't always want to have to calculate the number of pages we need let's add a function called allocate memory where we pass in the number of bytes that we need so in order to get the number of pages we need we just take bytes divided by page size and now if bytes percent page size that means there's some leftovers then we need to add another page to it so 4097 it would instead of one page it
(31:55) would be two pages so then we just return get free pages and now we want to be able to free that memory back too so let's say free memory give it the base address and now let's say we need to get the page number from that address so in order to get that first we cast to u64 subtract low memory and then divide that all by page size which is essentially what we did down here but the reverse of it so we're just kind of pulling that pointer apart and grabbing the data we need from it so now the number of pages that were
(32:48) allocated in it is going to be from that map value that i'd set when we set count there so then we can just say let's print some debug information here free memory see at address x page num percent d and pages percenty so base page number page so now in order to do the actual freeing all we essentially do is just set the value in memmap for each of the pages that we had allocated to zero so page num plus i equals zero okay so now let's go to our kernel dot c and just put some data in here that we can
(33:44) play around with our allocator so void p1 equals get free pages we'll get 10 pages let's just copy this we'll do p2 and p3 so we have 10 pages get four pages and this time we'll use the allocator so allocate memory only 20 pages of memory so we'll do 20 times 4096 and let's add one so we should that should be 21 pages instead because we have one over the amount we need okay so and then we can free these pointers when we're done so free memory p2 maybe do them in different order let's copy that paste
(34:44) so do free memory p one free memory p three or do we wanna do them in the same order just to make it easier to read yeah let's just do them in the same order just so it's easier to read the debugging statements so i'll just cut this and paste it in front of it so now we should be able to build it and and see the output of the debug so let's make okay and we'll take it out and we'll start it up give it a second to start here and now you'll see it printed out our get free pages return 10 pages at
(35:42) address 0 or at zero at address four hundred thousand and then four pages at a0 and 21 pages that looks all correct freeing the memory page number zero at pages 10 10 and then 14 so all that looks correct so yeah i think everything looks pretty good so uh you should be able to play around with that some play around with writing to those memory locations should be safe so i think that's really it that i wanted to cover for this video just wanted to kind of get back on track with the raspberry pi bare metal series
(36:22) so i think in the next one i want to start looking at how to read data from the sd card that's probably what i'll do in the next video because now the unlined stuff is all out of the way i'm able to do more things like that so i hope you enjoyed this video if you did like comment subscribe and we have a discord channel so uh discord server so if you want to join that i'll have that in the description as well so thanks for watching
