Raspberry Pi Bare Metal Tutorial - Part 14 (HDMI Video) - YouTube
https://www.youtube.com/watch?v=DxAxlc5Ldt4

Transcript:
(00:01) hi and welcome back to the low level devil channels raspberry pi bare metal series in the previous video we covered the video core mailbox properties api in this video we're going to use that api to create frame buffers so we can draw to the hdmi output so let's get started actually i also want to mention really quickly that i did set up a discord channel as some people have uh requested so it's a place that you can discuss some of these videos or things you know related to them and all that i'll put a
(00:32) link in the description i'll see if i can figure out how to put a link on this video as well okay i'm gonna start by adding a new header file so this will have this will be our video.h header file it'll have the the functions that we'll want to call from the kernel.c file so we'll start by using the pragma once and then a few headers we need to add common actually yeah we can just leave it at common so the first one we're going to create is a video set resolution and that will take in the x resolution
(01:14) the y resolution and bits per pixel okay and let's see next we need to create the video set sorry video draw char and that will take in a character a pause x and a pause y which is where we want to draw a character on the screen and then again we'll use the video draw string to draw those characters because you don't want to do one at a time and pretty much same interface except it takes the string instead of just a simple character okay now we need a couple of helper functions that that video header is
(02:09) going to need font get height font get width actually these are i'll just put a comment here that these are going to come from the font data.c which i'll create here and i'm just going to paste this in this actually comes from some linux code so i'm not going to really go over it in depth because it's it's not really that important for this video but you can see it's for the latin 16 console from this kbd keyboard and font utilities package by these people they're the original developers of it
(03:02) and it's essentially a gigantic char array that has all the pixel data for the latin 116 console font right so i'll you know i'll have this on the github so if you want to look at it there in in depth but there's not really much for me to explain here i'll run through it here real quick so you can see what it contains and that's what we'll use to actually draw these pixels from a font so i'm going to grab that function there font let's see was it yeah font get pixel that takes a character the xy position
(03:51) of that character to determine whether a pixel exists on the font at that point all right so now i'm going to create the video.c this is where we're going to actually implement the uh the video initialization and setting the resolution and all that start by including the mailbox header the printf header timer so we can do some timing on it and uh our video.
(04:26) h so i'm gonna cart start by creating some structures here the first one is going to be the mailbox frame buffer size and this is going to be one of those mailbox tags so we have the tag at the beginning and then two properties of x res and a y res now if you remember the definition for this we have the mailbox tag which is used in for instance a mailbox generic command so if you haven't watched the previous video you really want to understand this so you'll want to watch that video as well so now we're going to create a couple of
(05:02) more structures that are needed to create a frame buffer i'm just going to copy this so we have the again mailbox tag and remember they all have to start with that and this is going to be the bits per pixel so this is going to be the mailbox frame buffer depth okay so on this next one we're going to have the pitch which we'll call mailbox frame buffer pitch and this one will be the uh actual buffer so it'll have the base which is going to be the base address for the the video buffer and then the screen size
(05:58) so it'll return the actual number of pixels essentially that are on the screen or the uh i believe that's the size of the full buffer if i remember correctly we don't actually use that but it's in the api so now i'm going to create a structure that actually contains these structures and we're going to send this in one big chunk to the mailbox instead of one at a time so we're going to have this res and we're also going to have a virtual res which you can set a virtual resolution
(06:34) and then a physical resolution i'm just going to stick with them both being the same size for now but you can experiment with it so after those two resolutions comes the depth and then the buffer followed by the pitch and we'll call this the mailbox frame buffer request all right now that we have the essential structures for this i'm also going to take this request and just make it a static variable so i can reference reference it and other functions here so we'll start by creating the set resolution
(07:24) so it'll be the full video set resolution taking the x-rays the y-res bits per pixel so now i'm going to create this request object actually didn't need that request object but so so the fame frame buffer request res tag id so this is going to be our pi firmware let's see it's frame buffer set physical width height nice long variable name or not variable but constant so that's the tag id in the buffer size for this is going to be eight because we're giving it eight eight uh bytes total or yeah bytes total
(08:23) and the value length is also going to be eight so it's going to actually return the the value that it set it to as a response so let's see x-res and res to the values passed in so that's the first structure in the frame buffer request and the second one's really similar so i'm just going to copy and paste that change this physical to virtual and that's pretty much all it's need for the second one yep everything and oh yeah we need to change this to v-res can't forget that all right
(09:12) so now i'm pasting this again just as a start so now we want the depth i'll take depth depth depth depth this last one we won't need and the depth has bits per pixel bpp we want to set that to the value passed in and let's see this is going to be frame buffer set depth and the buffer size is only going to be 4 because it's only a 32-bit number and the length as well after the depth again comes that buffer so this one will be buff all right and it'll be frame buffer allocate and this one is going to be so the
(10:16) buffer size is going to be eight we're passing in eight and the value length is only going to be four because what yeah so so uh the value that we're passing in is only this this very first base value and then the buff dot screen size we don't actually pass that in but it will come back in the buffer so it'll have a valid value once we call the mailbox process function so let's do one more of these and this is going to be the pitch yes patch okay so we can just type pitch there copy paste through here
(11:10) and it should be just pitch yeah and the pitch we're going to set to zero because that's going to be not a set it's going to be a get and i typed this wrong hold on so that should be get pitch so essentially it's going to call all five of these commands at the same time and then return the data back in the structure we're passing it so we're going to make a call to that mailbox process function cast this to mailbox tag so fb request so at that point the uh the actual resolution will be set so
(12:04) if we can actually print out the location of that buffer that'll be the pointer for it and the size we can print that out too so buff.base and buff dot screen size so we'll just print that out to the uh console like we usually do then i'm gonna sleep for a couple seconds and before i start actually drawing stuff on the screen so this section is the sets the actual resolution and then down here we're going to actually draw a red square with a blue boundary so we'll say draw draw a blue box with a red box inside it
(13:04) on the screen actually before that too i think we want to print out what the resolution is so we'll draw some characters so we'll draw some text showing what resolution is set so let's create a string here s printf resolution percent d by percent d you'll need for a return there so i'm just going to write this to the screen all right x was y res and we'll call that video draw string pass in res and we'll put it in the upper left corner so 20 20.
(13:57) so so we got a little bit of a border on it so it's 20 characters to the right of the left and 20 characters down so now let's start working on drawing this screen contents so first we'll start with the square margin so the margin around the red square i'm going to say 100 pixels and you can play around with different values for this you know you're going to use this on your own thing anyway so so now we have the start milliseconds because i want to time it and see how long it actually takes to draw this
(14:46) screen because we're not using the gpu here we're actually going to be drawing to the memory directly with the cpu all right so and then four and y's res so now for each on the y coordinate now once we get to the coordinate 40 then we're going to actually redraw that text to the top because we would have drawn over top of it so i'm just gonna draw it again so we have it still there so you can see it and i'll see just the same thing video drawstring res 2020.
(15:42) so now inside of our y loop we're going to loop for each x as well now we need to get the pixel offset and the calculation for this is the x times 32 shifted over by 3 plus y times the depth or of the pitch so req dot pitch dot pitch yeah there we go so that will be the pixel offset for that x and y coordinate so the pixel offset in the frame buffer remember the frame buffer is going to be a big chunk of memory so now i'm just going to put a bowl here am i drawing the square or am i not drawing this graph so if i'm drawing the
(16:41) square i'm drawing the red square in the center otherwise i'm drawing the blue margin this can be just a simple y is greater than the square margin and y res minus y is greater than the square margin so we check the y size and we'll do the same thing for x essentially so that'll give us whether we're currently on the blue boundary or the red square and now we can use a helper function to draw this so video draw pixel x y and if draw a square is set we will use this red color a a for red 0 for g and 0
(17:44) for b or we'll use 0 for red 5 5 for g and b b for b hope that makes sense to you this is just a color which the ff is the alpha component of it which you don't really need to worry about right now so now at the end of this when we're done with it let's get the number of ticks there are now and figure out how long does this actually take to draw the screen and we're just going to reuse that little resolution character string draw took this many milliseconds and then i'll also include seconds so
(18:29) it'll be msnd minus ms start and ms and minus ms start divided by a thousand all right i think that's about it so now we're going to draw that string i'm going to put it at 20 40. so it's just under that previous string let's see what we have to do here let's just say done we'll print this to the console so we can see stuff's going on on the console and i'm gonna sleep another two seconds to give you time to read that little message and so now we need to implement a couple of those other helper functions
(19:24) we'll start with the draw pixel i think so void video draw pixel it's going to do x a y and a color so we want to draw this color at that x and y so now to implement this actually we need to do the volatile u8 pointer frame buffer so this is going to be our actual buffer in memory i'm using volatile so it doesn't get uh what do you call optimized out for some reason now this is a little bit of a magic numbers here i can't remember how i actually found this out but it was about a year or so ago i found out
(20:21) once you get this base you have to order it with this number and end it with the complement i think it is of that number there i'll i'll try to see see if i can find where i got those numbers from but it's been so long that uh i can't remember um if i do i'll put some details in the description all right so now i'm going to pull the red color out of that color so i'm just taking this first high byte i guess you'd call it shift it over by 24 take the green byte which is fff zero zero zero zero shift that over by
(21:05) sixteen if you don't understand this let me know we have uh i have a um what's that called discord channel but there's quite a few people in now so like i'm sure you can get help there on understanding this kind of stuff if you don't now take the alpha channel all right let's see so now what we want to do let's see if uh actually we want to get the pixel offset and actually i already got that didn't i um oh yeah i put up here it doesn't belong up here actually take that out that's before i had a helper function
(21:54) for this so down here and yeah it shouldn't be rq it should be frame buffer rdq all right so now if the depth is 32 bits so i'm really only going to show 32 bits for now but i'll put some code in so you can see like a 16 bit color as well but for this video i'm just to keep it not too long i'll just focus on the 32 bit yeah actually put that stuff up there because we're only splitting the colors like this for 32-bit so now i want to draw by setting the frame buffer pixel that pixel offset to do blue first
(22:55) and notice i'm plus plusing the pixel offset each time blue green red and then alpha because it's four bytes for each color or yeah for each pixel so otherwise i'm going to just use like a 16 bit color i'm not actually going to test this you can play around let me let me know if it doesn't work just shifting the top bite of that color over grabbing it and then getting the bottom bite of that color and i think that's all we need yeah because we're essentially drawing that color to this x and y coordinate inside the frame
(23:50) buffer memory chunk all right so now there's a couple other little functions we gotta create let's take a video draw character draw this character that position and for this one we need to let's see loop through all right so we're going to start it with y is 0 until y is the font height y plus plus and we'll do the same thing for x x is less than the font get width x plus plus oh yes equals font get pixel
(24:53) c x y it's just going to get i'm saying yes because it's basically saying is there a pixel on the font at this point otherwise it's the background so i'll draw it like so video draw a pixel and pause x plus x plus y plus y if yes is set i'll use text color otherwise back color and we'll actually need to define those text color and back color that should be text color we'll do let's do white for the text color so all f's essentially for back color we'll use that same
(25:57) shade of blue 5 bb ff and now we want to draw a string so let's see so we'll start with void video draw string take in the jar pointer pause x pause y and so this one we're going to loop through each index so we're going to loop from i zero to s i is not null essentially that's what not zero for and we want to increase the pause x by font get with plus two yeah we'll add a little spacer between each of the characters now for each of these let's see we want
(27:01) to essentially just draw the character right so we have our video draw char function so we can just make a use of that so it should be video draw char or car however you want to say it and which character we want to draw we want to draw s at index i and where do we want to do it we want to draw it at okay so yeah position x because we are incrementing that position x so that will be correct and then the position y should be just as is yeah so position x and position y all right is that all of them i think that's all of them
(28:02) so now we can go over into our kernel let's see kernel.c i'll just leave all this stuff in here i guess um i'll comment out some of these timer sleeps because we don't need to pause to see these things anymore and let's see i'll leave that sleep in there we'll do it right after this first get max temperature so do video and let's see def resolution the first one i'll do a fairly big one 1824 by 984 and i'll just call video set results i'm not showing up oh i need to put video.h up here
(29:12) video set resolution 1824 by 984 by 32 so i'm going to copy this and i'll do a couple different resolutions so we can see how they kind of perform against each other and how they look on the monitor okay let's see 1824 so after this one we'll do 10 24 by 768 that's a pretty popular smaller one we'll do 1900 by 1200 that's a pretty big one so 1900 1200 and well you do a really small one here yeah like uh 480 by was it 320 i think
(30:17) that's like an nes if i remember or something i used to program in a while so yeah it's a really small size there let's see if we can build this thing let me clean and make something messed up um defined reference font get high yep right there just forgot the t make all right before we go back to that there's a bug i found here in video drawstring yeah we're incriminating position but we also need to increment the eye otherwise we're going to sit there in that loop forever so all right now let's make
(31:24) still have some weirdness in here if i get height so let me i don't know why that's showing up all right i'll try to fix a couple things here this mailbox fb request shouldn't be there i think it's complaining about that and we'll say return true this is a ball a bool it's a return true i think we actually need a need that to be a boolean let me see is there anything else that came up video drop pixel why can't it find that is that not in our header let's look video draw pixel where is that called
(32:22) media draw pixel it's right there is in our video dot h no it's not okay we'll put it in there let me grab the full name for that let's see copy that also yeah let's change this to void while we're at it which doesn't need to be a bull okay and back to our video.h paste this in here do another build oh video set resolution void oh i forgot to change the definition for it or the declaration for it there you go i should have planned this a little bit better but all right let's building now i'm going
(33:25) to ignore this for now now that's building i'm just going to kind of jump forward here and and actually run it and i have to excuse my shaky hand here i'm going to show a little picture of it but i should have a better setup for uh showing the monitor which i will soon but here you can see we got the resolution 1824 by 984 now look how long it's taking to actually draw all those pixels it's quite a long time all right so that one let's do the next one is 1024 by 768. trying to zoom it out it took five
(34:08) seconds do this 1900 by 1200 and take this one's really chugging because we're essentially drawing each pixel one at a time to that location of memory which plots it on the frame buffer 16 seconds to do that the smallest one here that was quick but still one second which is essentially uh one uh sec one frame per second nobody wants to do uh one frame per second ui so so how do we fix that well one way to start is to use something called dma that's a direct memory access so instead of us writing code that interacts to move
(34:58) pixel by pixel we say here dma take this chunk of memory and map it over here to this device so and that's what we'll do in the next video and you'll see that'll make things a lot faster um not and i don't think that's how they actually do it in the linux kernel they probably use the gpu but unfortunately a lot of that stuff is just uh it's not open source it's all closed source but i think for a frame buffer at least it should be good enough for us to make some kind of real world use out of it so
(35:32) this again this one was just an introductory to show you how to start using frame buffers and drawing pixels in that next video we'll get on to dma and make things a lot quicker so i hope you enjoyed this video and learned something from it if you did please share it you know like comment subscribe and join our uh discord channel or discord server i'll put a link to that in the description as well so thanks again for watching
