Raspberry Pi Bare Metal Tutorial - Part 6 (Exception Levels & ARM stub) - YouTube
https://www.youtube.com/watch?v=zRhMutscRL0

Transcript:
(00:01) hi and welcome back in our previous video we finished the process of booting our bare metal app and connected to it via the mini ur to see the console output in this video i want to start the process of switching the exception level that the code runs in the exception model of the rnv8 architecture is laid out as shown in this diagram each exception level provides a different level of access to system resources each exception level is a different level of privilege essentially the current level of privilege can only
(00:38) change when the processor takes or returns from an exception so these privilege levels are referred to as exception levels each exception level is numbered and the higher levels of privilege have higher numbers the raspberry pi firmware boots up in el3 it has a boot stub which performs some additional initialization and moves into the hypervisor level el2 before passing control over to the kernel an os kernel typically runs in el1 and any application that it executes runs in el0 let's start by printing out the value of
(01:20) the current exception level when our code boots up before we get started i want to show um something i have here printf.h and a printf.c which which i just pasted into this project from sergey's tutorial and you see it's developed by this person here so i just took the code as is and i'm not going to go through it in detail it's just regular c code so but in order to use it we're going to need to actually initialize it with our uh our uart send so let's first uh see put we're going to create a put c
(02:02) function here that takes a void pointer and a char now we're going to annoy that ignore the first because we're just using uart and i'm doing this same thing that i did in our send string where if we send slash in we want to slide slash r as well and then we're going to send the character so in order to initialize it we first need to uh include the header so we're going to call this function init print f uh the first again the first uh value we can just put zero null and then we put in our function
(02:47) the name of our function that we just created there so then we can actually change any of these uarts and strings to a regular printf that every c programmer is familiar with and it'll support all the formatting that everybody expects and you can actually go ahead and build this and just show this working i'm gonna actually split the terminal here i'm gonna clean it make a version three make and this other split terminal i'm going to run the screen command to connect to our uh our raspberry pi so once i take the sd card out put it in
(03:35) the raspberry pi and boot it up and we see the boot up process and there we have the pi bare metal os initializing board raspberry pi 3 done just to show that it still boots up the same so let's create this utility function for getting the exception level we're going to call it get el and what this is going to do here we're going to use mrs x0 and current el is the name of the special register to get that value from it and then we're going to left shift it to get the actual el value and return so now let's just
(04:31) add a edit down here somewhere let's put a slash in up there all right so i'll say exception level and then percent d and we call our get el function and we need to define it up here 32 all right so now we're ready to rebuild and run this and you can see exception level two and now if you're following along with sergey's tutorial here
(05:35) one thing you'll notice is this kind of breaks things because when you go into lesson two here if you go down here he's actually expecting you to be an exception level three and that's because older versions of the raspberry pi os would send it to a exception level three but if we go here to the tools section of the raspberry pi github code there's this code called arm stubs if we look at the arm stubs eight that's the one that handles v8 you scroll down here we see the start location just just to show you here you don't
(06:10) need to understand this code but you see here we have a switch to el2 so it's switching to el2 and then it calls the primary cpu goes to this kernel 32 so this is where it's invoking the kernel after it's in el2 and it's also doing this secondary spin for all the other um cpu cores but we really don't want to do that we want it to be back in the firmware level so let's go ahead and create our own arm stub here so this one will just do really simple initialization and essentially just pass straight into the kernel without
(06:56) spinning the extra cores and switching to el2 so we want to just take it straight from the firmware essentially so what we're going to do is actually create a separate application called the arm stub and we'll create a separate folder here for it we'll call armstub as the separate folder and we're going to have our own source and build directory as well under here let's move that build directory back so we're going to have our own code here for this separate build module i'm going to call it onstar
(07:43) armstub.s so in here what we're essentially going to do here is start with our start section and we're going to use w0 to load the location of our kernel 30 kernel entry 32 and branch to that via the 64-bit register and we have some organization here we're creating in the file 0xf0 there's this specific value called stub magic that the firmware needs to find it has to have this exact value in that exact location or it's going to consider it to not be a valid arm stub so this is we're just kind of taking
(08:32) verbatim from that original arm stub code and then we also have here an arm stub version which is which version number is just a word of zero so now we have our actual location of our kernel 32 entry and this is where it's going to jump to to start executing the kernel which is going to be the value 0 to x0 so it's going to start from the very bottom of our from the very top of the binary file so let's update our make file here we need to create a couple of things i'm going to be lazy here and not add a
(09:19) bunch of extra variables so i'm just going to do arm stub build armstub s.o so i'm referencing our s file from the source i'm going to make the directory if it doesn't exist so now i'm gonna run the gcc against that dot s file with our options the same as before same the same as we do to create our our uh o files in the main application so now we actually have the arm stub itself which we're gonna of course rely on this dot o file let's see we're going to run the ld command this time it's a little
(10:19) different so we're doing section section dash text that section dash start equals dot text equals zero saying it's starting right at the very top and then we have armstub build armstub dot elf it's our output file armstub build armstub s.o is our input so now we're going to run the object copy to take that elf file and convert it into a binary object same as we did before for our main application so output type here is binary and we're going to call this arm stub dash new dot bins so it doesn't conflict with the existing
(11:12) one then we're going to copy it to our boot mount and call sync just to make sure the sd card i o is complete see let's just make clean here remake the main project and let's make the arm stub something's messed up here let's see dot glob okay yeah i just used the wrong word for here this glob should be global there you go make again hope one more error let's see okay see i figured out a problem it's this file here this should be dash o because that's our output file okay so now let's make
(12:13) and we copied everything and it all worked um uh yeah we need to update config.txt so config.txt we want to say arm stub equals our arm stub dash new dot bin so this will run our new arm stub code and now let's oops make clean remake so that our config.text gets copied over and let's go ahead and try to boot this in the raspberry pi so i'll take the sd card out here we go running it again and it's a little garbled up here let's see yeah you know i think this visual studio code is not good for uh running terminal commands
(13:12) like this in here yes as you can see some of the text is it's kind of out of sync so let me just just change this and go into the uh a linux console okay so i remove this console here i'll open up my bash terminal now i'm going to run it in here and let's boot up the raspberry pi with our new code you can see this looks much cleaner and there we go exception level 3 which is what we wanted to get so i think that's enough for this video to get us started on working with exception levels in our bare metal
(13:56) application in the next video i'll go over the process of getting our code to boot into el1 if you enjoyed this video or learned something useful from it please like and subscribe or post comments with any questions you may have and thanks again for watching
